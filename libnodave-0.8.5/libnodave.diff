diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/benchmark.c ../libnodave-0.8.5/benchmark.c
--- ../libnodave-0.8.4.6/benchmark.c	2007-01-08 23:24:30.000000000 +0100
+++ ../libnodave-0.8.5/benchmark.c	2013-05-22 17:54:21.000000000 +0200
@@ -1,3 +1,6 @@
+
+int benchcount =1000;  // was 101
+
 extern int seconds, thirds;
     void rBenchmark(daveConnection * dc, int bmArea) {
 	int i,res,maxReadLen,areaNumber;
@@ -10,7 +13,7 @@
 	clock_t t1, t2;
 #endif
 	seconds=0;thirds=0;
-	maxReadLen=dc->maxPDUlength-46;
+	maxReadLen=dc->maxPDUlength-22;
 	areaNumber=0; 
 	if(bmArea==daveDB) areaNumber=1;
     	printf("Now going to do read benchmark with minimum block length of 1.\n");
@@ -21,7 +24,7 @@
 #ifdef BCCWIN    
 	t1=clock();
 #endif	    
-	for (i=1;i<101;i++) {
+	for (i=1;i<benchcount;i++) {
     	    daveReadBytes(dc, bmArea, areaNumber,0, 1, NULL);
 	    if (i%10==0) {
 	        printf("...%d",i);
@@ -37,7 +40,7 @@
         t2=clock();
         usec = 0.001*(t2 - t1);
 #endif
-        printf(" 100 reads took %g secs. \n",usec);
+        printf(" %d reads took %g secs. \n",benchcount,usec);
 	printf(" retries: 2nd %d 3rd %d\n",seconds, thirds);
 	seconds=0;thirds=0;
 	
@@ -50,7 +53,7 @@
 #ifdef BCCWIN    
         t1=clock();
 #endif	    
-        for (i=1;i<101;i++) {
+        for (i=1;i<benchcount;i++) {
 	    daveReadBytes(dc, bmArea, areaNumber, 0, maxReadLen, NULL);
 	    if (i%10==0) {
 	        printf("...%d",i);
@@ -66,7 +69,7 @@
 	t2=clock();
 	usec = 0.001*(t2 - t1);
 #endif
-	printf(" 100 reads took %g secs. \n",usec);
+	printf(" %d reads took %g secs. \n",benchcount,usec);
 	printf(" retries: 2nd %d 3rd %d\n",seconds, thirds);
     	wait();
 	seconds=0;thirds=0;
@@ -79,7 +82,7 @@
 #ifdef BCCWIN    
 	t1=clock();
 #endif	    
-	for (i=1;i<101;i++) {
+	for (i=1;i<benchcount;i++) {
 	    davePrepareReadRequest(dc, &p);
 	    daveAddVarToReadRequest(&p,daveInputs,0,0,6);
 	    daveAddVarToReadRequest(&p,daveFlags,0,0,6);
@@ -102,7 +105,7 @@
 	t2=clock();
 	usec = 0.001*(t2 - t1);
 #endif
-	printf(" 100 reads took %g secs.\n",usec);
+	printf(" %d reads took %g secs. \n",benchcount,usec);
 	printf(" retries: 2nd %d 3rd %d\n",seconds, thirds);
 }
 
@@ -126,7 +129,7 @@
 #ifdef BCCWIN    
     t1=clock();
 #endif	    
-    for (i=1;i<101;i++) {
+    for (i=1;i<benchcount;i++) {
         daveWriteBytes(dc, bmArea, areaNumber,0,1,&c);
         if (i%10==0) {
 	    printf("...%d",i);
@@ -152,7 +155,7 @@
 #ifdef BCCWIN    
     t1=clock();
 #endif	    
-    for (i=1;i<101;i++) {		
+    for (i=1;i<benchcount;i++) {		
         daveWriteBytes(dc, bmArea, areaNumber, 0, maxWriteLen, &c);
         if (i%10==0) {
 	    printf("...%d",i);
@@ -178,4 +181,6 @@
 		block benchmarks. Must use V memory. This is like DB1 of S7-300/400, but a CPU
 		may have a DB1 or not depending on program. So in case of 300/400 use Merker/Flag
 		memory.
+Version 0.8.5
+    05/17/13  	use real maximum size of maxPDUsize-22
 */
Nur in ../libnodave-0.8.4.6/contributions: keith.
Nur in ../libnodave-0.8.5/Dot.NET: change.cs.
Nur in ../libnodave-0.8.5/Dot.NET: ch.cs.
Nur in ../libnodave-0.8.5/Dot.NET/CS: change.cs.
Binärdateien ../libnodave-0.8.4.6/Dot.NET/CS/simpleISO_TCP.exe and ../libnodave-0.8.5/Dot.NET/CS/simpleISO_TCP.exe sind verschieden.
Binärdateien ../libnodave-0.8.4.6/Dot.NET/CS/simpleMPI.exe and ../libnodave-0.8.5/Dot.NET/CS/simpleMPI.exe sind verschieden.
Binärdateien ../libnodave-0.8.4.6/Dot.NET/CS/simplePPI.exe and ../libnodave-0.8.5/Dot.NET/CS/simplePPI.exe sind verschieden.
Binärdateien ../libnodave-0.8.4.6/Dot.NET/CS/testMPI.exe and ../libnodave-0.8.5/Dot.NET/CS/testMPI.exe sind verschieden.
Binärdateien ../libnodave-0.8.4.6/Dot.NET/CS/testS7online.exe and ../libnodave-0.8.5/Dot.NET/CS/testS7online.exe sind verschieden.
Binärdateien ../libnodave-0.8.4.6/Dot.NET/libnodave.net.dll and ../libnodave-0.8.5/Dot.NET/libnodave.net.dll sind verschieden.
Binärdateien ../libnodave-0.8.4.6/ibhsim5 and ../libnodave-0.8.5/ibhsim5 sind verschieden.
Nur in ../libnodave-0.8.5: ibhsim5.o.
Binärdateien ../libnodave-0.8.4.6/isotest4 and ../libnodave-0.8.5/isotest4 sind verschieden.
Nur in ../libnodave-0.8.5: isotest4.o.
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/libnodave.DEF ../libnodave-0.8.5/libnodave.DEF
--- ../libnodave-0.8.4.6/libnodave.DEF	2009-07-10 23:27:14.000000000 +0200
+++ ../libnodave-0.8.5/libnodave.DEF	2013-05-21 15:28:50.000000000 +0200
@@ -166,9 +166,11 @@
 daveResetIBH
 daveSendMessage
 daveSetBit
+daveSetCommunicationType
 daveSetDebug
 daveSetPLCTime
 daveSetPLCTimeToSystime
+daveSetRoutingDestination
 daveSetTimeout
 daveStart
 daveStop
Nur in ../libnodave-0.8.5: libnodave.diff.
Nur in ../libnodave-0.8.5: libnodave.dll.
Nur in ../libnodave-0.8.5: libnodave.exp.
Nur in ../libnodave-0.8.5: libnodave.lib.
Binärdateien ../libnodave-0.8.4.6/libnodave.so and ../libnodave-0.8.5/libnodave.so sind verschieden.
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/log2.h ../libnodave-0.8.5/log2.h
--- ../libnodave-0.8.4.6/log2.h	2007-01-08 23:24:30.000000000 +0100
+++ ../libnodave-0.8.5/log2.h	2013-05-23 00:09:37.000000000 +0200
@@ -26,6 +26,31 @@
 
 
 #ifdef HAVE_PRINTF
+
+#define FLUSH fflush(logout)
+
+//#define LINENUMBERS
+
+
+#ifdef LINENUMBERS
+#define LOG1(a) fprintf(logout,"%20s() %4d :"a,__FUNCTION__,__LINE__)
+#define LOG2(a,b) fprintf(logout,"%20s() %4d :"a,__FUNCTION__,__LINE__,b)
+#define LOG3(a,b,c) fprintf(logout,"%20s() %4d :"a,__FUNCTION__,__LINE__,b,c)
+#define LOG4(a,b,c,d) fprintf(logout,"%20s() %4d :"a,__FUNCTION__,__LINE__,b,c,d)
+#define LOG5(a,b,c,d,e) fprintf(logout,"%20s() %4d :"a,__FUNCTION__,__LINE__,b,c,d,e)
+#define LOG6(a,b,c,d,e,f) fprintf(logout,"%20s() %4d :"a,__FUNCTION__,__LINE__,b,c,d,e,f)
+#define LOG7(a,b,c,d,e,f,g) fprintf(logout,"%20s() %4d :"a,__FUNCTION__,__LINE__,b,c,d,e,f,g)
+
+/*
+#define LOG1(a) fprintf(logout,"%14s %20s() %4d :"a,__FILE__,__FUNCTION__,__LINE__)
+#define LOG2(a,b) fprintf(logout,"%14s %20s() %4d :"a,__FILE__,__FUNCTION__,__LINE__,b)
+#define LOG3(a,b,c) fprintf(logout,"%14s %20s() %4d :"a,__FILE__,__FUNCTION__,__LINE__,b,c)
+#define LOG4(a,b,c,d) fprintf(logout,"%14s %20s() %4d :"a,__FILE__,__FUNCTION__,__LINE__,b,c,d)
+#define LOG5(a,b,c,d,e) fprintf(logout,"%14s %20s() %4d :"a,__FILE__,__FUNCTION__,__LINE__,b,c,d,e)
+#define LOG6(a,b,c,d,e,f) fprintf(logout,"%14s %20s() %4d :"a,__FILE__,__FUNCTION__,__LINE__,b,c,d,e,f)
+#define LOG7(a,b,c,d,e,f,g) fprintf(logout,"%14s %20s() %4d :"a,__FILE__,__FUNCTION__,__LINE__,b,c,d,e,f,g)
+*/
+#else
 #define LOG1(x) fprintf(logout,x)
 #define LOG2(x,y) fprintf(logout,x,y)
 #define LOG3(a,b,c) fprintf(logout,a,b,c)
@@ -33,7 +58,8 @@
 #define LOG5(a,b,c,d,e) fprintf(logout,a,b,c,d,e)
 #define LOG6(a,b,c,d,e,f) fprintf(logout,a,b,c,d,e,f)
 #define LOG7(a,b,c,d,e,f,g) fprintf(logout,a,b,c,d,e,f,g)
-#define FLUSH fflush(logout)
+
+#endif
 
 #define LOG_1(a) fprintf(logout,a)
 #define LOG_2(a,b) fprintf(logout,a,b)
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/Makefile ../libnodave-0.8.5/Makefile
--- ../libnodave-0.8.4.6/Makefile	2007-10-26 14:07:10.000000000 +0200
+++ ../libnodave-0.8.5/Makefile	2013-05-17 22:17:48.000000000 +0200
@@ -26,12 +26,16 @@
 
 #-static -Wl,static -lc.a -static -lpthread.a -nostdlib 
 #CFLAGS=-O0 -Wall -Winline
+#
+# modified to compile more important programs first. 5/17/2013
+#
 PROGRAMS=testIBH testISO_TCP testMPI testPPI \
-testPPIload testMPIload ibhsim5 \
-isotest4 \
+testPPIload testMPIload \
 testISO_TCPload testMPI_IBHload testPPI_IBHload testPPI_IBH \
 testNLpro \
-testAS511 
+testAS511 \
+isotest4 \
+ibhsim5
 
 
 
@@ -126,11 +130,14 @@
 libnodave.so: nodave.o setport.o openSocket.o
 	$(LD) -shared nodave.o setport.o openSocket.o -o libnodave.so	
 
+#
+# for some reason, -lpthread now has to be at the end of the linker command line...05/17/2013
+#
 ibhsim5.o: simProperties.c
 ibhsim5: ibhsim5.o nodave.h nodave.o openSocket.o openSocket.h
-	$(CC) -lpthread ibhsim5.o openSocket.o nodave.o -o ibhsim5
+	$(CC) ibhsim5.o openSocket.o nodave.o -lpthread  -o ibhsim5
 isotest4: isotest4.o openSocket.o nodave.o nodave.h
-	$(CC) $(LDFLAGS) -lpthread isotest4.o openSocket.o nodave.o $(LIB) -o isotest4
+	$(CC) $(LDFLAGS) isotest4.o openSocket.o nodave.o $(LIB)  -lpthread  -o isotest4
 
 clean: 
 	rm -f $(DYNAMIC_PROGRAMS)
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/nodave.c ../libnodave-0.8.5/nodave.c
--- ../libnodave-0.8.4.6/nodave.c	2013-05-18 13:52:57.000000000 +0200
+++ ../libnodave-0.8.5/nodave.c	2013-10-19 14:57:43.000000000 +0200
@@ -29,6 +29,7 @@
 #include "log2.h"
 #include <string.h>
 
+#define DUMPLIMIT 11132
 
 //#define DEBUG_CALLS	// Define this and recompile to get parameters and results
 			// of each function call printed. I could have made this an
@@ -201,7 +202,6 @@
 
 	    case daveProtoISOTCP:
 	    case daveProtoISOTCP243:
-	    case daveProtoISOTCPR:	// routing over MPI network
 		di->getResponse=_daveGetResponseISO_TCP;
 		di->connectPLC=_daveConnectPLCTCP;
 		di->exchange=_daveExchangeTCP;
@@ -234,6 +234,7 @@
 		di->sendMessage=_daveSendMessageS7online;
 		di->getResponse=_daveGetResponseS7online;
 		di->listReachablePartners=_daveListReachablePartnersS7online;
+		di->disconnectPLC=_daveDisconnectPLCS7online;
 //		di->disconnectAdapter=_daveDisconnectAdapterS7online;
 		break;		
 	    case daveProtoAS511:
@@ -616,8 +617,8 @@
     _daveAddValue(p, buffer, byteCount);
     if (daveDebug & daveDebugPDU) {
 	_daveDumpPDU(p);
-    }	
-}    
+    }
+}
 
 void DECL2 daveAddVarToWriteRequest(PDU *p, int area, int DBnum, int start, int byteCount, void * buffer) {
     uc da[]=	{0,4,0,0,};
@@ -775,13 +776,14 @@
 */
 void DECL2 _daveDump(char * name, void*b,int len) {//void DECL2 _daveDump(char * name,uc*b,int len) {
     int j;
-    LOG2("%s: ",name);
+    LOG2("%s:                             ",name);
     if (len>daveMaxRawLen) len=daveMaxRawLen; 	/* this will avoid to dump zillions of chars */
+    if (len>DUMPLIMIT) len=DUMPLIMIT; 		/* this will avoid large dumps */
     for (j=0; j<len; j++){
-	if((j & 0xf)==0) LOG2("\n%x:",j);
-	LOG2("0x%02X,",((uc*)(b))[j]);
+	if((j & 0xf)==0) LOG_2("\n                            %x:",j);
+	LOG_2("0x%02X,",((uc*)(b))[j]);
     }
-    LOG1("\n");
+    LOG_1("\n");
 }
 
 /*
@@ -798,7 +800,7 @@
 	pd=p->data;
 	for (i=0;i<p->param[1];i++) {
 	    _daveDump("Data hdr ",pd,4);
-	    
+	
 	    dl=0x100*pd[2]+pd[3];
 	    if (pd[1]==4) dl/=8;
 	    pd+=4;        
@@ -842,10 +844,10 @@
     name Objects:
 */
 char * DECL2 daveBlockName(uc bn) {
-#ifdef DEBUG_CALLS
+//#ifdef DEBUG_CALLS
     LOG2("daveBlockName(bn:%d)\n", bn);
     FLUSH;
-#endif	    	
+//#endif	    	
     switch(bn) {
 	case daveBlockType_OB: return "OB";
 	case daveBlockType_DB: return "DB";
@@ -1065,9 +1067,10 @@
         len+=p2.udlen;
 	printf("more data\n");
 	res=daveBuildAndSendPDU(dc, &p2,pam, sizeof(pam), NULL, 1);
+	if (res!=daveResOK) return res; 	// bugfix from Natalie Kather
     }
-    
-    
+
+
     if (res==daveResOK) {
 	if (buffer!=NULL) memcpy(buffer+len,p2.udata,p2.udlen);
         dc->resultPointer=p2.udata;
@@ -1097,11 +1100,12 @@
     LOG3("daveGetOrderCode(dc:%p buf:%p)\n", dc, buf);
     FLUSH;
 #endif	    	
-    daveBuildAndSendPDU(dc, &p2,pa, sizeof(pa), da, sizeof(da));
+    res=daveBuildAndSendPDU(dc, &p2,pa, sizeof(pa), da, sizeof(da));
+    if (res!=daveResOK) return res; // similar to bugfix from Natalie Kather
     if (buf) {
 	memcpy(buf, p2.udata+10, daveOrderCodeSize);
 	buf[daveOrderCodeSize]=0;
-    }	
+    }
     return res;
 }
 
@@ -1125,7 +1129,8 @@
     da[2]=index / 0x100;
     da[3]=index % 0x100;
     res=daveBuildAndSendPDU(dc, &p2,pa, sizeof(pa), da, sizeof(da));
-    
+    if (res!=daveResOK) return res; // similar to bugfix from Natalie Kather
+
     len=0;
     pa7=p2.param[7];
 //    pa6=p2.param[6];
@@ -1141,9 +1146,10 @@
 		pam[7]=pa7;
 //		res=daveBuildAndSendPDU(dc, &p2,pam, sizeof(pam), NULL, sizeof(dam));
 		res=daveBuildAndSendPDU(dc, &p2,pam, sizeof(pam), NULL, 1);
+		if (res!=daveResOK) return res; // similar to bugfix from Natalie Kather
     }
-    
-    
+
+
     if (res==daveResOK) {
 	if (buffer!=NULL) {
           cpylen = p2.udlen;
@@ -1158,8 +1164,7 @@
     return res;
 }
 
-int DECL2 daveGetBlockInfo(daveConnection * dc, daveBlockInfo *dbi, uc type, int number)
-{
+int DECL2 daveGetBlockInfo(daveConnection * dc, daveBlockInfo *dbi, uc type, int number) {
     int res;
     uc pa[]={0,1,18,4,17,67,3,0};	   /* param */
     uc da[]={'0',0,'0','0','0','1','0','A'};
@@ -1168,6 +1173,7 @@
     da[1]=type;
     da[7]='A';
     res=daveBuildAndSendPDU(dc, &p2,pa, sizeof(pa), da, sizeof(da));    
+    if (res!=daveResOK) return res; // similar to bugfix from Natalie Kather
     if ((dbi!=NULL) && (p2.udlen==sizeof(daveBlockInfo))) {
 	memcpy(dbi, p2.udata, p2.udlen);
 	dbi->number=daveSwapIed_16(dbi->number);
@@ -1180,18 +1186,19 @@
     int res,i;
     PDU p2;
     uc pa[]={0,1,18,4,17,67,1,0};
-    daveBuildAndSendPDU(dc, &p2, pa, sizeof(pa), NULL, 1/*da, sizeof(da)*/);
+    res=daveBuildAndSendPDU(dc, &p2, pa, sizeof(pa), NULL, 1/*da, sizeof(da)*/);
+    if (res!=daveResOK) return res; // similar to bugfix from Natalie Kather
     res=p2.udlen/sizeof(daveBlockTypeEntry);
     if (buf) {
 	memcpy(buf, p2.udata, p2.udlen);
 	for (i=0; i<res; i++) {
 	    buf[i].count=daveSwapIed_16(buf[i].count);
-	}	
-    }	
+	}
+    }
     return res;
 }
 
-int DECL2 daveReadManyBytes(daveConnection * dc,int area, int DBnum, int start,int len, void * buffer){
+int DECL2 daveReadManyBytes(daveConnection * dc,int area, int DBnum, int start,int len, void * buffer) {
     int res, pos, readLen;
     uc * pbuf;
     pos=0;
@@ -1503,23 +1510,28 @@
 	dc->connectionNumber=di->nextConnection;	// 1/10/05 trying Andrew's patch
 	
 	dc->PDUnumber=0xFFFE;			// just a start value; // test!
-	dc->messageNumber=0;			
+	dc->messageNumber=0;
+	dc->communicationType=davePGCommunication;
+
 	switch (di->protocol) {
 	    case daveProtoMPI:		/* my first Version of MPI */
 		dc->PDUstartO=8;	/* position of PDU in outgoing messages */
 		dc->PDUstartI=8;	/* position of PDU in incoming messages */
 		di->ackPos=6;		/* position of 0xB0 in ack packet */
+		dc->maxPDUlength=240;	/* limit because we still cannot assemble a PDU transported in multiple packets */
 		break;
 	    case daveProtoMPI3:		/* Step 7 Version of MPI */
 		dc->PDUstartO=8;	/* position of PDU in outgoing messages */
 		dc->PDUstartI=12;	/* position of PDU in incoming messages */
 		di->ackPos=10;		/* position of 0xB0 in ack packet */
+		dc->maxPDUlength=240;	/* limit because we still cannot assemble a PDU transported in multiple packets */
 		break;	
 	    case daveProtoMPI2:		/* Andrew's Version of MPI */
 	    case daveProtoMPI4:		/* Andrew's Version of MPI with extra STX */
 		dc->PDUstartO=6;	/* position of PDU in outgoing messages */
 		dc->PDUstartI=6;	/* position of PDU in incoming messages */
 		di->ackPos=4;		/* position of 0xB0 in ack packet */
+		dc->maxPDUlength=240;	/* limit because we still cannot assemble a PDU transported in multiple packets */
 		break;	
 
 	    case daveProtoNLpro:	/* Deltalogic NetLink Pro */	
@@ -1540,29 +1552,29 @@
 		di->timeout=1500000;
 		break;	
 	    case daveProtoMPI_IBH:	
-		dc->maxPDUlength=240;	// limit for NetLink as reported by AFK 
+//		dc->maxPDUlength=240;	// limit for NetLink as reported by AFK. Not needed any more. Now, a PDU can be split into multiple IBH packets.
 		dc->PDUstartI= sizeof(IBHpacket)+sizeof(MPIheader);	
 		dc->PDUstartO= sizeof(IBHpacket)+sizeof(MPIheader); // 02/01/2005	
 		break;
 	    case daveProtoPPI_IBH:	
-	        dc->maxPDUlength=240;	// limit for NetLink as reported by AFK 
+//	        dc->maxPDUlength=240;	// limit for NetLink as reported by AFK
 		dc->PDUstartI=14; // sizeof(IBHpacket)+7;	
 		dc->PDUstartO=13;// sizeof(IBHpacket)+7; // 02/01/2005	
 		break;	
 		
-	    case daveProtoAS511:	
+	    case daveProtoAS511:
 		dc->PDUstartI=0; 
 		dc->PDUstartO=0;
-		break;		
+		break;
 	    
-	    case daveProtoUserTransport:	
+	    case daveProtoUserTransport:
 		dc->PDUstartI=0;
 		dc->PDUstartO=0;
-		break;	
-	    case daveProtoS7online:	
+		break;
+	    case daveProtoS7online:
 		dc->PDUstartI=80;
 		dc->PDUstartO=80;
-		break;		
+		break;
 
 	    default:
 		dc->PDUstartO=8;	/* position of PDU in outgoing messages */
@@ -1576,6 +1588,21 @@
     return dc;	
 }
 
+void DECL2 daveSetRoutingDestination(daveConnection * dc, int subnet1,int subnet3,int adrsize, uc* plcadr) {
+    memset(&(dc->routingData), 0, sizeof(daveRoutingData));
+    dc->routing=1;
+    dc->routingData.subnetID1=subnet1;
+    dc->routingData.subnetID2=0;
+    dc->routingData.subnetID3=subnet3;
+    dc->routingData.PLCadrsize=adrsize;
+    memcpy(&(dc->routingData.PLCadr), plcadr, adrsize);
+}
+
+void DECL2 daveSetCommunicationType(daveConnection * dc,  int communicationType) {
+    dc->communicationType=communicationType;
+}
+
+
 int DECL2 daveWriteManyBytes(daveConnection * dc,int area, int DBnum, int start,int len, void * buffer){
     int res, pos, writeLen;
     uc * pbuf;
@@ -2104,7 +2131,7 @@
     f+=100*(b[1] & 0xf);
     return (f);    
 }
-/*	
+/*
     get counter value from random read position:
 */
 int DECL2 daveGetCounterValueAt(daveConnection * dc,int pos){
@@ -2141,7 +2168,7 @@
     MPI specific functions:
 */
 
-/* 
+/*
     This writes a single chracter to the serial interface:
 */
 
@@ -2165,19 +2192,19 @@
 int DECL2 _daveReadMPI(daveInterface * di, uc *b) {
 	int res=0,state=0,nr_read;
 	uc bcc=0;
-rep:	
+rep:
 	{	
 	    nr_read= di->ifread(di, (char*)(b+res), 1);
 	    if (nr_read==0) return 0;
 	    res+=nr_read;
 	    if ((res==1) && (*(b+res-1)==DLE)) {
 		if ((daveDebug & daveDebugSpecialChars)!=0)
-		    LOG1("readMPI single DLE.\n");
+		    LOG1("readMPI single DLE!\n");
 		return 1;
 	    }		
 	    if ((res==1) && (*(b+res-1)==STX)) {
 		if ((daveDebug & daveDebugSpecialChars)!=0)
-		    LOG1("readMPI single STX.\n");
+		    LOG1("readMPI single STX!\n");
 	        return 1;
 	    }
 	    if (*(b+res-1)==DLE) {
@@ -2189,7 +2216,7 @@
 */			
 		} else if (state==1) {
 		    state=0;
-		    res--;		/* forget this DLE */
+		    res--;		/* forget this DLE, it is the second of a pair */
 /*		    if ((daveDebug & daveDebugSpecialChars)!=0)
 		        LOG1("readMPI 2nd DLE in data.\n") 
 		    ;
@@ -2198,10 +2225,10 @@
 	    } 	
 	    if (state==3) {
 	        if ((daveDebug & daveDebugSpecialChars)!=0)
-			LOG3("readMPI: packet end, got BCC: %x. I calc: %x\n",*(b+res-1),bcc);
-		if ((daveDebug & daveDebugRawRead)!=0)	
-		    _daveDump("answer",b,res);	
-		return res;	    				
+		    LOG4("readMPI: packet size %d, got BCC: %x. I calc: %x\n",res,*(b+res-1),bcc);
+		if ((daveDebug & daveDebugRawRead)!=0)
+		    _daveDump("answer",b,res);
+		return res;
 	    } else {
 		bcc=bcc^(*(b+res-1));
 	    }
@@ -2216,12 +2243,51 @@
     }
 
 int DECL2 _daveReadMPI2(daveInterface * di, uc *b) {
-	int res=_daveReadMPI(di, b);
-	if (res>1) {
-		_daveSendSingle(di, DLE);
-		_daveSendSingle(di, STX);
-	}
-	return res;
+    uc b6;
+    uc b2[daveMaxRawLen];
+    uc fix[]= {04,0x80,0x80,0x0C,0x03,0x14,5,1,0};
+    int res2, re;
+    int res=_daveReadMPI(di, b);
+    re=res;
+    b6=b[6];
+again:
+    if ((re>=7)&&(b6==0xF0)) {
+	if ((daveDebug & daveDebugRawRead)!=0)
+	    LOG1("follow up expected\n");
+//	uc fix[]= {04,0x80,0x80,0x0C,0x03,0x14,0xB0,0,0};
+//	uc fix[]= {04,0x80,0x80,0x0C,0x03,0x14,5,1,0};
+/*
+	uc m[3];
+	m[0]=0xB1;
+        m[1]=0x01;
+	m[2]=nr;
+*/	
+	fix[8]=b[7];
+	fix[1]=b[1];
+	_daveSendSingle(di, DLE);
+	_daveSendSingle(di, STX);
+	_daveReadSingle(di);
+	_daveSendWithCRC(di, fix, sizeof(fix));
+	_daveReadSingle(di);
+	_daveReadSingle(di);
+	_daveSendSingle(di, STX);
+	_daveSendSingle(di, DLE);
+//	_daveReadSingle(di);
+//	_daveReadSingle(di);
+	res2=_daveReadMPI(di, b2);
+	b6=b2[6];
+	re=res2;
+	memcpy(b+res-3, b2+6, res2-9);
+	res+=res2-9;
+	b[7]++;		// increase packet number for ack
+	goto again;
+    }
+    if (res>1) {
+        _daveSendSingle(di, DLE);
+        _daveSendSingle(di, STX);
+    }
+
+    return res;
 }
 
 int DECL2 _daveGetAck(daveConnection * dc) {
@@ -2257,8 +2323,7 @@
 
 
 #define tmo_normal 95000
-
-/* 
+/*
     This reads up to max chracters when it can get them and returns the number:
 */
 int DECL2 _daveReadChars2(daveInterface * di,	/* serial interface */
@@ -2296,7 +2361,7 @@
 //    daveWriteFile(di->fd.wfd, target, targetSize, wr);
     di->ifwrite(di, (char*)target, targetSize);
     if (daveDebug & daveDebugPacket)
-	    _daveDump("_daveSendWithCRC",target, targetSize);
+	_daveDump("_daveSendWithCRC",target, targetSize);
     return 0;
 }
 
@@ -2373,7 +2438,8 @@
 */
 int DECL2 _daveIncMessageNumber(daveConnection * dc) {
 	int res=dc->messageNumber++;	
-//	LOG2("_daveIncMessageNumber new number %d \n", dc->messageNumber);
+	if (daveDebug & daveDebugPacket)
+	    LOG2("_daveIncMessageNumber new number %d \n", dc->messageNumber);
 	if ((dc->messageNumber)==0) dc->messageNumber=1;
 	return res;
 }	
@@ -2385,8 +2451,14 @@
     int a;
     _daveSendSingle(dc->iface, STX);
     if (_daveReadSingle(dc->iface)!=DLE) {
-        LOG2("%s *** no DLE before send.\n", dc->iface->name);	    
-	return -1;
+	if (daveDebug & daveDebugPrintErrors)
+	    LOG2("%s *** no DLE before send.\n", dc->iface->name);
+        _daveSendSingle(dc->iface, DLE);
+	if (_daveReadSingle(dc->iface)!=DLE) {
+	    if (daveDebug & daveDebugPrintErrors)
+		LOG2("%s retry*** no DLE before send.\n", dc->iface->name);
+	    return -1;
+	}
     } 
     if (size>5){
 	dc->needAckNumber=dc->messageNumber;
@@ -2701,289 +2773,7 @@
 	return sum;
 }
 
-/*
-us ccrc(uc *b, int size, us start) {
-    us sum;
-    int i, j;
-//    LOG3("crc start:%04x size%d\n",start,size);
-    sum = start;
-    for (j = 0; j < size; j++) {
-	sum = sum ^ (b[j]);
-	for (i = 0; i <= 7; i++) {
-	    if (sum & 0x1) {
-		sum = sum >> 1;
-		sum = sum ^ 0x8408;
-	    } else
-		sum = sum >> 1;
-	}
-    }
-    return sum;
-}
-*/
-/*
-    MPI3 has a quite complicated CRC. It seems that a different start value is needed depending
-    on length of data. Maybe it only seems so due to my lack of mathematical capabilities...
-    I could find values for most message lengths making a CPU produce them. Most of the missing 
-    ones may never occur at all.
-*/
-/*
-us startTab[]={0x0000 , // 0
-0x0000 , // 1
-0x0000 , // 2
-0xbdb7 , // 3
-0x0000 , // 4
-0x0000 , // 5
-0x0000 , // 6
-0xab86 , // 7
-0x4169 , // 8
-0xc854 , // 9
-0x0000 , // 10
-0x0000 , // 11
-0x0000 , // 12
-0x0000 , // 13
-0x0000 , // 14
-0x0000 , // 15
-0x0000 , // 16
-0x0000 , // 17
-0x2d56 , // 18
-0x0000 , // 19
-0x167a , // 20
-0x0000 , // 21
-0x0000 , // 22
-0xb376 , // 23
-0x0000 , // 24
-0x0000 , // 25
-0x7ca2 , // 26
-0xe0a8 , // 27
-0x23b0 , // 28
-0x1f25 , // 29
-0x61c8 , // 30
-0x6365 , // 31
-0xde47 , // 32
-0x377f , // 33
-0x7171 , // 34
-0x5b75 , // 35
-0x05ee , // 36
-0x7b72 , // 37
-0x08df , // 38
-0x22af , // 39
-0x0834 , // 40
-0xc9af , // 41
-0x6618 , // 42
-0x8b12 , // 43
-0xdf58 , // 44
-0x206e , // 45
-0xd916 , // 46
-0x5e08 , // 47
-0x50bb , // 48
-0x9355 , // 49
-0x59c0 , // 50
-0xa0cc , // 51
-0x53d2 , // 52
-0xe266 , // 53
-0xfd92 , // 54
-0xf07d , // 55
-0x77a0 , // 56
-0xba13 , // 57
-0x5d68 , // 58
-0x2888 , // 59
-0x7f9e , // 60
-0xc49b , // 61
-0x3ac5 , // 62
-0xa3ac , // 63
-0x2be1 , // 64
-0x0ead , // 65
-0x60c9 , // 66
-0x6a74 , // 67
-0x87de , // 68
-0x7394 , // 69
-0xae57 , // 70
-0xb83c , // 71
-0x624a , // 72
-0xf956 , // 73
-0x1439 , // 74
-0x2573 , // 75
-0xec43 , // 76
-0xa87c , // 77
-0xa35a , // 78
-0xdde1 , // 79
-0x894c , // 80
-0x917a , // 81
-0x66e2 , // 82
-0x7112 , // 83
-0x3875 , // 84
-0x038e , // 85
-0x2b14 , // 86
-0xfbad , // 87
-0xff1b , // 88
-0x695f , // 89
-0xb4ed , // 90
-0xd386 , // 91
-0x9ea2 , // 92
-0xc61d , // 93
-0xace7 , // 94
-0x181e , // 95
-0x62bf , // 96
-0x0c56 , // 97
-0x8beb , // 98
-0x2658 , // 99
-0xdf70 , // 100
-0x086e , // 101
-0x93af , // 102
-0xa3c0 , // 103
-0x47e1 , // 104
-0x7032 , // 105
-0x1064 , // 106
-0x5837 , // 107
-0x5fdd , // 108
-0x8daa , // 109
-0x573e , // 110
-0x2e22 , // 111
-0xe5f8 , // 112
-0x5be5 , // 113
-0x95ee , // 114
-0xd2a6 , // 115
-0xb6b3 , // 116
-0x9da4 , // 117
-0xd82e , // 118
-0x6e19 , // 119
-0xca9a , // 120
-0x4b2b , // 121
-0xdafe , // 122
-0xae3b , // 123
-0xd43c , // 124
-0x1cd5 , // 125
-0x89fb , // 126
-0x267a , // 127
-0xfd70 , // 128
-0x127d , // 129
-0x5115 , // 130
-0x3544 , // 131
-0x5a53 , // 132
-0x2bff , // 133
-0x10ad , // 134
-0x9137 , // 135
-0x2be2 , // 136
-0x0dad , // 137
-0x78fa , // 138
-0x98ec , // 139
-0xb87b , // 140
-0x254a , // 141
-0xd543 , // 142
-0x6bc4 , // 143
-0x3fcf , // 144
-0x81f9 , // 145
-0x64f2 , // 146
-0x7130 , // 147
-0x1a75 , // 148
-0x199d , // 149
-0xe9ae , // 150
-0x6d29 , // 151
-0xe2a9 , // 152
-0x3292 , // 153
-0xb424 , // 154
-0x1a86 , // 155
-0xea9d , // 156
-0x461a , // 157
-0x8323 , // 158
-0xaed0 , // 159
-0x3f3c , // 160
-0x72f9 , // 161
-0xcb46 , // 162
-0x9f3a , // 163
-0x560c , // 164
-0x1433 , // 165
-0x2f73 , // 166
-0xbce9 , // 167
-0x970e , // 168
-0x2284 , // 169
-0x2334 , // 170
-0x9b25 , // 171
-0x6948 , // 172
-0xa3ed , // 173
-0x6ae1 , // 174
-0x12de , // 175
-0xf215 , // 176
-0x0f82 , // 177
-0x47d8 , // 178
-0x4932 , // 179
-0xd3dc , // 180
-0xc4a2 , // 181
-0x03c5 , // 182
-0x6014 , // 183
-0xb774 , // 184
-0x52b5 , // 185
-0x8d77 , // 186
-0x8a3e , // 187
-0xfb49 , // 188
-0x1b1b , // 189
-0x7f8c , // 190
-0xd69b , // 191
-0xabf7 , // 192
-0x3069 , // 193
-0x5f06 , // 194
-0x56aa , // 195
-0xb233 , // 196
-0x3de0 , // 197
-0xbedb , // 198
-0xb52c , // 199
-0x1a97 , // 200
-0xfb9d , // 201
-0xcf1b , // 202
-0xe27e , // 203
-0xe592 , // 204
-0x31e5 , // 205
-0xdb17 , // 206
-0x4f2a , // 207
-0xfbba , // 208
-0xe81b , // 209
-0xd038 , // 210
-0x3891 , // 211
-0xe78e , // 212
-0x3dc7 , // 213
-0x99db , // 214
-0x876a , // 215
-0xc794 , // 216
-0x2df6 , // 217
-0x29cb , // 218
-0x348f , // 219
-0x9942 , // 220
-0x1e6a , // 221
-0x26d9 , // 222
-0x5e70 , // 223
-0x28bb , // 224
-0x4c9e , // 225
-0x5789 , // 226
-0x9922 , // 227
-0x7e6a , // 228
-0x388a , // 229
-0xfc8e , // 230
-0xe46c , // 231
-0xc7f4 , // 232
-0x4df6 , // 233
-0x3798 , // 234
-0x9671 , // 235
-0x5595 , // 236
-0x9500 , // 237
-0x3ca6 , // 238
-0xf0ca , // 239
-0xc0a0 , // 240
-0x2181 , // 241
-0x3e07 , // 242
-0x41e8 , // 243
-0x4954 , // 244
-0xb5dc , // 245
-0xea97 , // 246
-0x4c1a , // 247
-0xd389 , // 248
-0x0000 , // 249
-0x0000 , // 250
-0x0000 , // 251
-0x0000 , // 252
-0x0000 , // 253
-0x0000 , // 254
-};
-*/
+
 int daveSendWithCRC3(daveInterface * di, uc* buffer,int length) {
     uc target[daveMaxRawLen];
     us crc;
@@ -3139,7 +2929,7 @@
 int DECL2 _daveListReachablePartnersMPI3(daveInterface * di,char * buf) {
     uc b1[daveMaxRawLen];
     uc m1[]={1,7,2};
-    int res;
+    int res, len;
     daveSendWithCRC3(di,m1,sizeof(m1));
     res=read1(di, b1);
     if (daveDebug & daveDebugInitAdapter)
@@ -3158,58 +2948,68 @@
     (or reused for the same PLC ?)
 */
 int DECL2 _daveConnectPLCMPI3(daveConnection * dc) {
-    int res, mpi;
-    
+    int res, mpi, len;
     PDU p1;
     uc b1[daveMaxRawLen];
+    uc * pcha;
     
-    uc e18[]={0x04,0x82,0x00,
-	    0x0d,0x00,0x14,0xe0,0x04,0x00,0x80,
-	    0x00,0x02,0x00,0x02,
+    uc e18[]={0x04,0x82,0x00,0x0d,0x00,0x14,
+	0xe0,0x04,0x00,0x80,0x00,0x02,
+	    0x00,0x02,
 	    0x01,
 	    0x00,
 	    0x01,0x00,
-//	    0x02,0x03,0x01,0x00
+	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 	    };
-    uc b4[]={
-	0x00,0x0d,0x00,0x03,0xe0,0x04,0x00,0x80,
-	0x00,0x02,0x01,0x06,
-	0x01,
-	0x00,
-	0x00,0x01,
-	0x02,0x03,0x01,0x00
-           /*^^ MPI ADDR */
-	};
 
-    us t4[]={
-	0x00,0x0c,0x103,0x103,0xd0,0x04,0x00,0x80,
-	0x01,0x06,
-	0x00,0x02,0x00,0x01,0x02,
-	0x03,0x01,0x00,
-	0x01,0x00,0x10,0x03,0x4d
-    };
+//Step7
+//7E 00 1F E0 
+//04 86 00 0D 00 14   
+//E0 04 00 80 00 02   
+//01 
+//0F  
+// 01 00  
+// 06 04 02  sizes
+// AA BB 00 00 CC DD  
+// C0 A8 02 BC  
+// 01 03 8C 60 7E 	
+
     uc b5[]={	
 	0x05,0x01,
     };
-    
-    b4[3]=dc->connectionNumber; // 1/10/05 trying Andrew's patch
-    b4[sizeof(b4)-3]=dc->MPIAdr;	
-    t4[15]=dc->MPIAdr;
-    t4[sizeof(t4)/2-1]^=dc->MPIAdr; /* 'patch' the checksum	*/
+
     mpi=dc->MPIAdr;
-//    dc->MPIAdr=2;
-//    e18[sizeof(e18)-3]=dc->MPIAdr;
     e18[1]|=dc->MPIAdr;
-    daveSendWithCRC3(dc->iface,e18,sizeof(e18));
+    
+    pcha=e18+16;
+    len=18;
+    if(dc->routing) {
+	e18[12]=1;
+	e18[13]=11+dc->routingData.PLCadrsize;
+	*pcha=6; pcha++;
+	*pcha=dc->routingData.PLCadrsize; pcha++;
+	*pcha=2; pcha++;
+	*pcha=(dc->routingData.subnetID1) / 0x100; pcha++;
+	*pcha=(dc->routingData.subnetID1) % 0x100; pcha++;
+	*pcha=(dc->routingData.subnetID2) / 0x100; pcha++;
+	*pcha=(dc->routingData.subnetID2) % 0x100; pcha++;
+	*pcha=(dc->routingData.subnetID3) / 0x100; pcha++;
+	*pcha=(dc->routingData.subnetID3) % 0x100; pcha++;
+	memcpy(pcha, dc->routingData.PLCadr, dc->routingData.PLCadrsize);
+	pcha+=dc->routingData.PLCadrsize;
+	len=27+dc->routingData.PLCadrsize;
+    }
+    *pcha=dc->communicationType; pcha++; 
+    *pcha=0; pcha++; // rack+slot ?
+    
+    daveSendWithCRC3(dc->iface,e18, len);
     read1(dc->iface, b1);
     
-//    dc->connectionNumber2=b1[3]; // 1/10/05 trying Andrew's patch
     dc->connectionNumber2=b1[9];
     dc->connectionNumber=0x14;
 
     if (daveDebug & daveDebugConnect) 
 	LOG2("%s daveConnectPLC() step 3.\n", dc->iface->name);	
-//    res=_daveReadMPI(dc->iface,b1);
 
     if (daveDebug & daveDebugConnect) 
 	LOG2("%s daveConnectPLC() step 4.\n", dc->iface->name);	
@@ -3425,7 +3225,7 @@
     if (daveDebug & daveDebugInitAdapter) 
 	LOG2("%s daveDisconnectAdapter() step 2.\n", di->name);	
     _daveSendSingle(di, DLE);
-    _daveReadChars2(di, b1, daveMaxRawLen);
+    di->ifread(di, b1, daveMaxRawLen);
 //    _daveReadChars(di, b1, tmo_normal, daveMaxRawLen);
     _daveSendSingle(di, DLE);
     if (daveDebug & daveDebugInitAdapter) 
@@ -3495,7 +3295,10 @@
     build the PDU for a PDU length negotiation    
 */
 int DECL2 _daveNegPDUlengthRequest(daveConnection * dc, PDU *p) {
-    uc pa[]=	{0xF0, 0 ,0, 1, 0, 1, 3, 0xC0,};
+    uc pa[]=	{0xF0, 0 ,0, 1, 0, 1, 
+    dc->maxPDUlength / 0x100, //3, 		
+    dc->maxPDUlength % 0x100, //0xC0,
+    };
     int res;
     int CpuPduLimit;
     PDU p2;
@@ -3604,23 +3407,34 @@
     (or reused for the same PLC ?)
 */
 int DECL2 _daveConnectPLCMPI1(daveConnection * dc) {
-    int res;
+    int res, len;
     PDU p1;
+    uc * pcha;
+    
     uc b4[]={
-	0x04,0x80,0x80,0x0D,0x00,0x14,0xE0,0x04,
-	0x00,0x80,0x00,0x02,
+	0x04,0x80,0x80,0x0D,0x00,0x14,
+	0xE0,0x04,0x00,0x80,0x00,0x02,
 	0x00,
 	0x02,
 	0x01,0x00,
 	0x01,0x00,
+	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
     };
 
+	//7E 11 1F E0 04 82 00 0D 00 14   
+	//E0 04 00 80 00 02   
+	//01 0F  
+	//01 00  
+	//06 04 02  AA BB 00 00 CC DD  C0 A8 02 BC  01 03 18 87 7E 	
+	//Step7//7E 00 1F E0 04 86 00 0D 00 14   E0 04 00 80 00 02   01 0F  01 00  06 04 02  AA BB 00 00 CC DD  C0 A8 02 BC  01 03 8C 60 7E 	
+
     us t4[]={
 	0x04,0x80,0x180,0x0C,0x114,0x103,0xD0,0x04,	// 1/10/05 trying Andrew's patch
 	0x00,0x80,
 	0x00,0x02,0x00,0x02,0x01,
 	0x00,0x01,0x00,
     };
+
     uc b5[]={	
 	0x05,0x01,
     };
@@ -3632,16 +3446,42 @@
     b4[1]|=dc->MPIAdr;	
     b4[5]=dc->connectionNumber; // 1/10/05 trying Andrew's patch
     
+//    b4R[1]|=dc->MPIAdr;	
+//    b4R[5]=dc->connectionNumber; // 1/10/05 trying Andrew's patch
+    
     t4[1]|=dc->MPIAdr;	
     t5[1]|=dc->MPIAdr;	
 
-    _daveInitStep(dc->iface, 1, b4, sizeof(b4),"connectPLC(1)");
+    pcha=b4+16;
+    len=18;
+    if(dc->routing) {
+	b4[12]=1;
+	b4[13]=11+dc->routingData.PLCadrsize;
+	*pcha=6; pcha++;
+	*pcha=dc->routingData.PLCadrsize; pcha++;
+	*pcha=2; pcha++;
+	*pcha=(dc->routingData.subnetID1) / 0x100; pcha++;
+	*pcha=(dc->routingData.subnetID1) % 0x100; pcha++;
+	*pcha=(dc->routingData.subnetID2) / 0x100; pcha++;
+	*pcha=(dc->routingData.subnetID2) % 0x100; pcha++;
+	*pcha=(dc->routingData.subnetID3) / 0x100; pcha++;
+	*pcha=(dc->routingData.subnetID3) % 0x100; pcha++;
+	memcpy(pcha, dc->routingData.PLCadr, dc->routingData.PLCadrsize);
+	pcha+=dc->routingData.PLCadrsize;
+	*pcha=1; pcha++;
+	*pcha=0; pcha++;
+	len=27+dc->routingData.PLCadrsize;
+    }
+    _daveInitStep(dc->iface, 1, b4, len,"connectPLC(1)");
+    
     
     res= _daveReadMPI2(dc->iface,dc->msgIn);
-    if (_daveMemcmp(t4, dc->msgIn, sizeof(t4)/2)) return 3;
+
+    if (_daveMemcmp(t4, dc->msgIn, 10)) return 3;
+
     dc->connectionNumber2=dc->msgIn[5]; // 1/10/05 trying Andrew's patch
     if (daveDebug & daveDebugConnect) 
-	LOG2("%s daveConnectPLC(1) step 4.\n", dc->iface->name);	
+	LOG2("%s daveConnectPLC(1) step 4.\n", dc->iface->name);
     
     if (_daveReadSingle(dc->iface)!=DLE) return 4;
     if (daveDebug & daveDebugConnect) 
@@ -3694,220 +3534,181 @@
 }
 #endif 
 
-#ifdef HAVE_SELECT
 /*
-    Read one complete packet. The bytes 3 and 4 contain length information.
-    This version needs a socket filedescriptor that is set to O_NONBLOCK or
-    it will hang, if there are not enough bytes to read.
-    The advantage may be that the timeout is not used repeatedly.
+    Universal receive with timeout:
 */
-int DECL2 _daveReadISOPacket(daveInterface * di,uc *b) {
-	int res,length;
-	fd_set FDS;
-	struct timeval t;
-	FD_ZERO(&FDS);
-	FD_SET(di->fd.rfd, &FDS);
-	
-	t.tv_sec = di->timeout / 1000000;
-	t.tv_usec = di->timeout % 1000000;
-	if (select(di->fd.rfd + 1, &FDS, NULL, NULL, &t) <= 0) {
-	    if (daveDebug & daveDebugByte) LOG1("timeout in ReadISOPacket.\n");
-	    return 0;
-	} else {
-	res=read(di->fd.rfd, b, 4);
-        if (res<4) {
-	    if (daveDebug & daveDebugByte) {
-		LOG2("res %d ",res);
-		_daveDump("readISOpacket: short packet", b, res);
-	    }
-	    return (0); /* short packet */
-	}
-	length=b[3]+0x100*b[2];
-	res+=read(di->fd.rfd, b+4, length-4);
-	if (daveDebug & daveDebugByte) {
-	    LOG3("readISOpacket: %d bytes read, %d needed\n",res, length);
-	    _daveDump("readISOpacket: packet", b, res);    
-	}
-	return (res);
-    }
-}
-/*
-    struct timeval t;
-    fd_set FDS,EFDS;
-*/
-int DECL2 _daveReadIBHPacket(daveInterface * di,uc *b) {
-    struct timeval t;
-    fd_set FDS,EFDS;
-    int res,length;
-    t.tv_sec = di->timeout / 1000000;
-    t.tv_usec = di->timeout % 1000000;
-    
-    FD_ZERO(&FDS);
-    FD_ZERO(&EFDS);
-    FD_SET(di->fd.rfd, &FDS);
-    FD_SET(di->fd.rfd, &EFDS);
-	
-//    LOG2("time %d\n",di->timeout);	
-//    if (select(di->fd.rfd + 1, &FDS, NULL, NULL, &t) <= 0) {
-    res= select(di->fd.rfd + 1, &FDS, NULL, &EFDS, &t);
-//    LOG2("select returned:%d\n",res);	
-//    LOG3("rest time %d %d\n",t.tv_sec,t.tv_usec);	
-//    if FD_ISSET(di->fd.rfd, &FDS)
-//	LOG1("true\n");	
-//    if FD_ISSET(di->fd.rfd, &EFDS)
-//	LOG1("e true\n");		
-//    if (select(di->fd.rfd + 1, &FDS, NULL, NULL, &t) <= 0) {
-    if(res<=0) {
-        if (daveDebug & daveDebugByte) LOG1("timeout in ReadIBHPacket.\n");
-	    return 0;
-    } else {
-        res=read(di->fd.rfd, b, 3);
-	if (res==0) {
-	    t.tv_sec = 0;
-	    t.tv_usec = 20000;
-	    res= select(0, NULL, NULL, NULL, &t);
-//	    LOG3("rest time 2 %d %d\n",t.tv_sec,t.tv_usec);	
-	}
-//        res=recv(di->fd.rfd, b, 3,0);
-	if (res<3) {
-	    if (daveDebug & daveDebugByte) {
-//	        LOG2("res %d ",res);
-//	        _daveDump("readIBHpacket: short packet", b, res);
-	    }
-	    return (0); /* short packet */
-	}
-	length=b[2]+8; //b[3]+0x100*b[2];
-	res+=read(di->fd.rfd, b+3, length-3);
-	if (daveDebug & daveDebugByte) {
-	    LOG3("readIBHpacket: %d bytes read, %d needed\n",res, length);
-	    _daveDump("readIBHpacket: packet", b, res);    
-	}
-	return (res);
-    }
-}
-#endif /* HAVE_SELECT */
-
-#ifdef BCCWIN
-
-int DECL2 _daveReadISOPacket(daveInterface * di,uc *b) {
-    int res,i,length;
+int DECL2 _daveTimedRecv(daveInterface * di, uc *b, int len){
     fd_set FDS;
     struct timeval t;
     FD_ZERO(&FDS);
+#ifdef BCCWIN
     FD_SET((SOCKET)(di->fd.rfd), &FDS);
-	
+#endif
+#ifdef LINUX
+    FD_SET(di->fd.rfd, &FDS);
+#endif
     t.tv_sec = di->timeout / 1000000;
     t.tv_usec = di->timeout % 1000000;
-    if (select(/*di->fd.rfd +*/ 1, &FDS, NULL, NULL, &t) <= 0) {
-        if (daveDebug & daveDebugByte) LOG1("timeout in ReadIBHPacket.\n");
+#ifdef BCCWIN
+    if (select(1, &FDS, NULL, NULL, &t) <= 0) {
+        if (daveDebug & daveDebugByte) LOG1("timeout in TCP read.\n");
 	    return 0;
     } else {
-	i=recv((SOCKET)(di->fd.rfd), b, 4, 0);
-	res=i;
-	if (res <= 0) {
-	    if (daveDebug & daveDebugByte) LOG1("timeout in ReadISOPacket.\n");
+	return recv((SOCKET)(di->fd.rfd), b, len, 0);
+    }
+#endif
+
+#ifdef LINUX
+    if (select(di->fd.rfd+1, &FDS, NULL, NULL, &t) <= 0) {
+        if (daveDebug & daveDebugByte) LOG1("timeout in TCP read.\n");
 	    return 0;
-	} else {
-    	    if (res<4) {
-	    if (daveDebug & daveDebugByte) {
-		LOG2("res %d ",res);
-		_daveDump("readISOpacket: short packet", b, res);
-	    }
-	    return (0); /* short packet */
-	}
-	length=b[3]+0x100*b[2];
-	i=recv((SOCKET)(di->fd.rfd), b+4, length-4, 0);
-	res+=i;
-	if (daveDebug & daveDebugByte) {
-	    LOG3("readISOpacket: %d bytes read, %d needed\n",res, length);
-	    _daveDump("readISOpacket: packet", b, res);    
-	}
-	return (res);
-	}
+    } else {
+	return read(di->fd.rfd, b, len);
     }
+#endif
 }
 
+int DECL2 _daveReadIBHPacket2(daveInterface * di,uc *b) {
+    int res, len;
+    res=_daveTimedRecv(di, b, 3);
+    if (res<3) {
+        if (daveDebug & daveDebugByte) {
+	    LOG2("res %d ",res);
+	    _daveDump("readIBHpacket2: short packet", b, res);
+        }
+        return (0); /* short packet */
+    }
+    len=b[2]+8;
+    res+=_daveTimedRecv(di, b+3, len-3);
+    if (daveDebug & daveDebugByte) {
+        LOG3("readIBHpacket2: %d bytes read, %d needed\n",res, len);
+        _daveDump("readIBHpacket2: packet", b, res);
+    }
+//    _daveDump("readIBHpacket2: packet", b, 8);
+    return res;
+}
+
+
+
+uc IBHfollow[]={
+	0,0,7,0xb,
+	0,0,0x82,0,
+	0,0,0,0,
+	2,5,1
+    };
+
+
 int DECL2 _daveReadIBHPacket(daveInterface * di,uc *b) {
-    int res,length;
-    fd_set FDS;
-    struct timeval t;
-    FD_ZERO(&FDS);
-    FD_SET((SOCKET)(di->fd.rfd), &FDS);
+    int res,res2,len2;
+    uc b2[300];
+    res= _daveReadIBHPacket2(di, b);
+
+    if ((res>15) && (b[15]==0xf0)) {
+again:	    
+//	    LOG1("FOLLOW UP\n");
+	    
+	    IBHfollow[0]=b[1];
+	    IBHfollow[1]=b[0];
+	    IBHfollow[8]=b[8];
+	    IBHfollow[9]=b[9];
+	    IBHfollow[10]=b[10];
+	    IBHfollow[11]=b[11];
 	
-    t.tv_sec = di->timeout / 1000000;
-    t.tv_usec = di->timeout % 1000000;
-    if (select(/*di->fd.rfd +*/ 1, &FDS, NULL, NULL, &t) <= 0) {
-        if (daveDebug & daveDebugByte) LOG1("timeout in ReadIBHPacket.\n");
-	    return 0;
-    } else {
-//	res=read(di->fd.rfd, b, 3);
-	res=recv((SOCKET)(di->fd.rfd), b, 3, 0);
-        if (res<3) {
-	    if (daveDebug & daveDebugByte) {
-		LOG2("res %d ",res);
-		_daveDump("readIBHpacket: short packet", b, res);
-	    }
-	    return (0); /* short packet */
+//	    _daveDump("IBHfollow", IBHfollow, 15);
+
+	    res2=send((unsigned int)(di->fd.wfd), IBHfollow, 15, 0);
+
+//	    LOG2("send: res2:%d\n",res2);
+
+	    res2= _daveReadIBHPacket2(di, b2);
+//	    LOG2("read: res2:%d\n",res2);
+	    res2= _daveReadIBHPacket2(di, b2);
+//	    LOG2("read: res2:%d\n",res2);
+
+//	    if ((res>15) && (b[15]==0xf0)) 
+	    memcpy(b+res,b2+17,res2-17);
+	    b[16]=b2[16];
+	    res+=res2-17;
+	    b[15]=0xf1;
+//	    LOG2("new b2[15]: %d\n",b2[15]);
+	    if ((res>15) && (b2[15]==0xf0)) goto again;
 	}
-	length=b[2]+8; //b[3]+0x100*b[2];
-//	res+=read(di->fd.rfd, b+3, length-3);
-	res+=recv((SOCKET)(di->fd.rfd), b+3, length-3, 0);
+
 	if (daveDebug & daveDebugByte) {
-	    LOG3("readIBHpacket: %d bytes read, %d needed\n",res, length);
-	    _daveDump("readIBHpacket: packet", b, res);    
+	    LOG2("readIBHpacket: %d bytes read\n",res);
+//	    _daveDump("readIBHpacket: packet", b, res);
 	}
+
 	return (res);
-    }
 }
 
 /*
-int DECL2 _daveReadIBHPacket(daveInterface * di,uc *b) {
-	int res,i,length;
-	i=recv((SOCKET)(di->fd.rfd), b, 3, 0);
+    Read one complete packet. 
+*/
+int DECL2 _daveReadISOPacket(daveInterface * di,uc *b) {
+	int res,i,length, follow;
+	uc lhdr[7];
+	i=_daveTimedRecv(di, b, 4);
+	if (i<0) return 0;
 	res=i;
-	if (res <= 0) {
-	    if (daveDebug & daveDebugByte) LOG1("timeout in ReadIBHPacket.\n");
-	    return 0;
-	} else {
-    	    if (res<3) {
+        if (res<4) {
 	    if (daveDebug & daveDebugByte) {
 		LOG2("res %d ",res);
-		_daveDump("readIBHpacket: short packet", b, res);
+		_daveDump("readISOpacket: short packet", b, res);
 	    }
-	    return (0); // short packet 
+	    return (0); /* short packet */
 	}
-	length=b[2]+8; //b[3]+0x100*b[2];
-	i=recv((SOCKET)(di->fd.rfd), b+3, length-3, 0);
+	length=b[3]+0x100*b[2];
+	i=_daveTimedRecv(di, b+4, length-4);
 	res+=i;
 	if (daveDebug & daveDebugByte) {
-	    LOG3("readIBHpacket: %d bytes read, %d needed\n",res, length);
-	    _daveDump("readIBHpacket: packet", b, res);    
+	    LOG3("readISOpacket: %d bytes read, %d needed\n",res, length);
+	    _daveDump("readISOpacket: packet", b, res);
+	}
+	follow=((b[5]==0xf0)&& ((b[6] & 0x80)==0) );
+	while (follow) {
+	    if (daveDebug & daveDebugByte) {
+		LOG2("readISOpacket: more data follows %d\n",b[6]);
+	    }
+	    i=_daveTimedRecv(di, lhdr, 7);
+	    length=lhdr[3]+0x100*lhdr[2];
+	    if (daveDebug & daveDebugByte) {
+		_daveDump("readISOpacket: follow %d %d", lhdr, i);
+	    }
+	    i=_daveTimedRecv(di, b+res, length-7);
+	    if (daveDebug & daveDebugByte) {
+		_daveDump("readISOpacket: follow %d %d", b+res, i);
+	    }
+	    res+=i;
+	    follow=((lhdr[5]==0xf0)&& ((lhdr[6] & 0x80)==0) );
 	}
 	return (res);
-    }
 }
-*/
 
-#endif /* */
 
 int DECL2 _daveSendISOPacket(daveConnection * dc, int size) {
     unsigned long i;
+    int res;
     size+=4;
-    *(dc->msgOut+3)=size % 0x100;	//was %0xFF, certainly a bug	
-    *(dc->msgOut+2)=size / 0x100;
-    *(dc->msgOut+1)=0;
-    *(dc->msgOut+0)=3;
-    if (daveDebug & daveDebugByte) 
-	_daveDump("send packet: ",dc->msgOut,size);
+    *(dc->msgOut+dc->partPos+3)=size % 0x100;	//was %0xFF, certainly a bug
+    *(dc->msgOut+dc->partPos+2)=size / 0x100;
+    *(dc->msgOut+dc->partPos+1)=0;
+    *(dc->msgOut+dc->partPos+0)=3;
+    if (daveDebug & daveDebugByte)
+	_daveDump("send packet: ",dc->msgOut+dc->partPos,size);
 #ifdef HAVE_SELECT
-    daveWriteFile(dc->iface->fd.wfd, dc->msgOut, size, i);
-#endif    
+    daveWriteFile(dc->iface->fd.wfd, dc->msgOut+dc->partPos, size, i);
+#endif
 #ifdef BCCWIN
-    send((unsigned int)(dc->iface->fd.wfd), dc->msgOut, size, 0);
+    res = send((SOCKET)(dc->iface->fd.wfd), dc->msgOut+dc->partPos, size, 0);
+    if (res==SOCKET_ERROR )
+	if (daveDebug & daveDebugPrintErrors) LOG2("_daveSendISOPacket WSAGetLastError: %d \n",WSAGetLastError());
+    
 #endif
     return 0;
 }
 
+
 #define ISOTCPminPacketLength 16
 int DECL2 _daveGetResponseISO_TCP(daveConnection * dc) {
     int res;
@@ -3925,85 +3726,103 @@
     Executes the dialog around one message:
 */
 int DECL2 _daveExchangeTCP(daveConnection * dc, PDU * p) {
-    int res;
+    int res, totLen, sLen;
+
     if (daveDebug & daveDebugExchange) {
         LOG2("%s enter _daveExchangeTCP\n", dc->iface->name);
-    }    
-    *(dc->msgOut+6)=0x80;
-    *(dc->msgOut+5)=0xf0;
-    *(dc->msgOut+4)=0x02;
-    _daveSendISOPacket(dc,3+p->hlen+p->plen+p->dlen);
+    }
+
+//    _daveSendISOPacket(dc,3+p->hlen+p->plen+p->dlen);
+
+    dc->partPos=0;
+    totLen=p->hlen+p->plen+p->dlen;
+    while(totLen) {
+        if (totLen>dc->TPDUsize) {
+	    sLen=dc->TPDUsize;
+	    *(dc->msgOut+dc->partPos+6)=0x00;
+	} else {
+	    sLen=totLen;
+	    *(dc->msgOut+dc->partPos+6)=0x80;
+	}
+	*(dc->msgOut+dc->partPos+5)=0xf0;
+	*(dc->msgOut+dc->partPos+4)=0x02;
+	_daveSendISOPacket(dc,3+sLen);
+	totLen-=sLen;
+	dc->partPos+=sLen;
+    }
+
     res=_daveReadISOPacket(dc->iface,dc->msgIn);
     if(res==7) {
-	if (daveDebug & daveDebugByte) 
+	if (daveDebug & daveDebugByte)
 	    LOG1("CPU sends funny 7 byte packets.\n");
 	res=_daveReadISOPacket(dc->iface,dc->msgIn);
     }
     if (daveDebug & daveDebugExchange) {
-        LOG3("%s _daveExchangeTCP res from read %d\n", dc->iface->name,res);	    
+        LOG3("%s _daveExchangeTCP res from read %d\n", dc->iface->name,res);
     }
-    if (res==0) return daveResTimeout; 
+    if (res==0) return daveResTimeout;
     if (res<=ISOTCPminPacketLength) return  daveResShortPacket; 
     return 0;
 }
 
 int DECL2 _daveConnectPLCTCP(daveConnection * dc) {
-    int res, success, retries;
+    int res, success, retries, i, px;
     uc b4[]={
 	0x11,0xE0,0x00,
 	0x00,0x00,0x01,0x00,
 	0xC1,2,1,0,
-	0xC2,2,0,1,
-	0xC0,1,9,
+	0xC2,2,
+	dc->communicationType,
+	(dc->slot | dc->rack<<5), // hope I got it right this time...
+	0xC0,1,0x9,
     };
 
-    uc b4R[]={			// for routing
-	6 + 30 + 30 + 3,	// Length over all without this byte (fixed
-				// Data 6 Bytes + size of Parameters (3 for C0h,30 for C1h+C2h)
+    uc b4R2[]={			// for routing
+	6+30+30+3,		// Length over all without this byte (6 byte fixed data, 30 bytes source TSAP (C1), 30 bytes dest TSAP (C2), 3 bytes TPDU size (C0))
 
 	0xE0,		// TDPU Type CR = Connection Request (see RFC1006/ISO8073)
 	0x00,0x00,	// TPDU Destination Reference (unknown)
 	0x00,0x01,	// TPDU Source-Reference (my own reference, should not be zero)
-	0x00,		// TPDU Class 0 and no Option 
+
+	0x00,		// TPDU Class 0 and no Option
 
 	0xC1,		// Parameter Source-TSAP
-	28,		// Length of this parameter 
+	28,		// Length of this parameter
 	1,		// one block of data (???)
 	0,		// Length for S7-Subnet-ID
 	0,		// Length of PLC-Number
 	2,		// Length of Function/Rack/Slot
-	0,0,0,0,0,0,0,0,	// empty Data 
-	0,0,0,0,0,0,0,0,
-	0,0,0,0,0,0,
+	0,0,0,0, 0,0,0,0,	// empty Data 
+	0,0,0,0, 0,0,0,0,
+	0,0,0,0, 0,0,
 	1,		// Function (1=PG,2=OP,3=Step7Basic)
 	0,		// Rack (Bit 7-5) and Slot (Bit 4-0)
 
 	0xC2,		// Parameter Destination-TSAP
 	28,		// Length of this parameter 
 	1,		// one block of data (???)
+
 	6,		// Length for S7-Subnet-ID
-	1,		// Length of PLC-Number
+	1,		// Length of PLC address
 	2,		// Length of Function/Rack/Slot
 
-	0xFF,0xFF,		// first part of S7-Subnet-ID 
-				// (look into the S7Project/Network configuration)
+	0x01,0x52,		// first part of S7-Subnet-ID  (look into the S7Project/Network configuration)
 	0x00,0x00,		// fix always 0000 (reserved for later use ?)
-	0xFF,0xFF,		// second part of S7-Subnet-ID 
+	0x00,0x13,		// second part of S7-Subnet-ID 
 				// (see S7Project/Network configuration)
 
-	18,			// PLC-Number (0-126)
+	0x01,			// PLC address
 
 	0,0,0,0,0,0,0,0,	// empty 
 	0,0,0,0,0,0,0,
 
-	1,		// Function (1=PG,2=OP,3=Step7Basic)
-	2,		// Rack (Bit 7-5) and Slot (Bit 4-0)
-			// 0 for slot = let select the plc itself the correct slotnumber
+	dc->communicationType,		// Function (1=PG,2=OP,3=Step7Basic)
+	(dc->slot | dc->rack<<5),	// Rack (Bit 7-5) and Slot (Bit 4-0) hope I got it right this time...
 
 	0xC0,		// Parameter requested TPDU-Size
 	1,		// Length of this parameter 
-	9,		// requested TPDU-Size 8=256 Bytes, 9=512 Bytes 
-    };	
+	0x9,		// requested TPDU-Size 8=256 Bytes, 9=512, a=1024 Bytes 
+    };
 
     uc b243[]={
 	0x11,0xE0,0x00,
@@ -4016,29 +3835,55 @@
     PDU p1;	
     success=0;
     retries=0;
+    dc->partPos=0;
     
-	if (dc->iface->protocol==daveProtoISOTCP243) {
-	    memcpy(dc->msgOut+4, b243, sizeof(b243));	
-	} else if (dc->iface->protocol==daveProtoISOTCP) {
+    if (dc->iface->protocol==daveProtoISOTCP243) {
+        memcpy(dc->msgOut+4, b243, sizeof(b243));	
+    } else if (dc->iface->protocol==daveProtoISOTCP) {
+        if(!dc->routing) {
 	    memcpy(dc->msgOut+4, b4, sizeof(b4));
-//	    printf("******** do inc %d\n",a);
-	    dc->msgOut[17]=dc->rack+1;
-	    dc->msgOut[18]=dc->slot;
+	    dc->msgOut[17]=dc->communicationType;  // (1=PG Communication,2=OP Communication,3=Step7Basic Communication)
+	    dc->msgOut[18]=dc->slot | dc->rack<<5; // hope I got it right this time...
 	} else {
-	    memcpy(dc->msgOut+4, b4R, sizeof(b4R));	// with routing over MPI
-	    dc->msgOut[17]=dc->rack+1;			// this is probably wrong
-	    dc->msgOut[18]=dc->slot;
-	}	
-    	
-        _daveSendISOPacket(dc, sizeof(b4)); /* sizes are identical */
-    do {	
+	    if (daveDebug & daveDebugConnect) {
+		_daveDump("routing data 1: ", (char*)&(dc->routingData), 30);
+	    }
+	    b4R2[41]=dc->routingData.PLCadrsize;
+
+	    px=43;
+	    b4R2[px]=(dc->routingData.subnetID1) / 0x100;
+	    b4R2[px+1]=(dc->routingData.subnetID1) % 0x100;
+	    b4R2[px+2]=(dc->routingData.subnetID2) / 0x100;
+	    b4R2[px+3]=(dc->routingData.subnetID2) % 0x100;
+	    b4R2[px+4]=(dc->routingData.subnetID3) / 0x100;
+	    b4R2[px+5]=(dc->routingData.subnetID3) % 0x100;
+	    
+	    memcpy(b4R2+49, dc->routingData.PLCadr, dc->routingData.PLCadrsize);
+	    
+	    memcpy(dc->msgOut+4, b4R2, sizeof(b4R2));	// with routing over MPI
+	    
+//	    dc->msgOut[17]=dc->rack+1;			// this is probably wrong
+//	    dc->msgOut[18]=dc->slot;
+	}
+    }
+
+    _daveSendISOPacket(dc, dc->msgOut[4]+1);
+    do {
 	res=_daveReadISOPacket(dc->iface,dc->msgIn);
         if (daveDebug & daveDebugConnect) {
 	    LOG2("%s daveConnectPLC() step 1. ", dc->iface->name);	
 	    _daveDump("got packet: ", dc->msgIn, res);
 	}
-	if (res==22) {
+	if ((res==22 && !dc->routing) || (res==48 && dc->routing)|| (res==74 && dc->routing)) {
 	    success=1;
+	    for (i=6;i<res;i++) {
+		if (dc->msgIn[i]==0xc0) {
+		    dc->TPDUsize=128 << (dc->msgIn[i+2]-7);
+		    if (daveDebug & daveDebugConnect) {
+			LOG3("TPDU len %d = %d\n",dc->msgIn[i+2],dc->TPDUsize);
+		    }
+		}
+	    }
 	} else {
 	    if (daveDebug & daveDebugPrintErrors){
 		LOG2("%s error in daveConnectPLC() step 1. retrying...", dc->iface->name);	
@@ -4127,7 +3972,7 @@
     b=dc->msgIn;
     alt=1;
     while ((expectingLength)||(res<expectedLen)) {
-	i = _daveReadChars2(dc->iface, dc->msgIn+res, 1);
+	i = dc->iface->ifread(dc->iface, dc->msgIn+res, 1);
 	res += i;
 	if ((daveDebug & daveDebugByte)!=0) {
 	    LOG3("i:%d res:%d\n",i,res);
@@ -4188,7 +4033,7 @@
     len=3+p1->hlen+p1->plen+p1->dlen;	/* The 3 fix bytes + all parts of PDU */
     _daveSendLength(dc->iface, len);			
     _daveSendIt(dc->iface, dc->msgOut, len);
-    i = _daveReadChars2(dc->iface, dc->msgIn+res, 1);
+    i = dc->iface->ifread(dc->iface, dc->msgIn+res, 1);
     if ((daveDebug & daveDebugByte)!=0) {
 	LOG3("i:%d res:%d\n",i,res);
 	_daveDump("got",dc->msgIn,i); // 5.1.2004
@@ -4197,12 +4042,12 @@
 	seconds++;
 	_daveSendLength(dc->iface, len);			
 	_daveSendIt(dc->iface, dc->msgOut, len);
-	i = _daveReadChars2(dc->iface, dc->msgIn+res, 1);
+	i = dc->iface->ifread(dc->iface, dc->msgIn+res, 1);
 	if (i == 0) {
 	    thirds++;
 	    _daveSendLength(dc->iface, len);			
 	    _daveSendIt(dc->iface, dc->msgOut, len);
-	    i = _daveReadChars2(dc->iface, dc->msgIn+res, 1);
+	    i = dc->iface->ifread(dc->iface, dc->msgIn+res, 1);
 	    if (i == 0) {
 		LOG1("timeout in _daveExchangePPI!\n");
 		FLUSH;
@@ -5072,10 +4917,11 @@
 	}
 	
 	if (pm->func==0xb0) {
-	    if (daveDebug & daveDebugMPI)    
+	    if (daveDebug & daveDebugMPI)
     		LOG2("Ackknowledge for packet number: %d\n",pm->packetNumber);
 	} else {
-	    LOG2("Unsupported MPI function code !!: %d\n",pm->func);
+	    if (daveDebug & daveDebugMPI)
+		LOG2("Unsupported MPI function code !!: %d\n",pm->func);
 	    _daveSendMPIAck_IBH(dc);
 	}
     }
@@ -5119,7 +4965,7 @@
 	    pt=__daveAnalyze(dc);
 	if (daveDebug & daveDebugExchange)    
 	    LOG2("ExchangeIBH packet type:%d\n",pt);
-    } while ((pt!=55)&&(count<5));
+    } while ((pt!=55)&&(count<7));	// 05/21/2013
     if(pt!=55) return daveResTimeout;
     return 0;
 }
@@ -5130,7 +4976,7 @@
     it will send this byte sequence.
     It will then wait for a packet and compare it to the sample.
 */
-int DECL2 _daveInitStepIBH(daveInterface * iface, uc * chal, int cl, us* resp,int rl, uc*b) {
+int DECL2 _daveInitStepIBH(daveInterface * iface, uc * chal, int cl, us* resp, int rl, uc*b) {
     int res, res2, a=0;
     if (daveDebug & daveDebugConnect) 
 	LOG1("_daveInitStepIBH before write.\n");
@@ -5157,7 +5003,7 @@
 		if (daveDebug & daveDebugInitAdapter) 
 		    LOG3("*** Got response %d %d\n",res,rl);
 		return a;
-	    }  else {	
+	    }  else {
 		if (daveDebug & daveDebugInitAdapter)  
 		    LOG2("wrong! %d\n",res2);
 	    }
@@ -5244,10 +5090,58 @@
 };
 
 uc chal8[]={
-	0x07,0xff,0x11,0x02,0x00,0x00,0x82,0x00, 0x14,0x00,0x02,0x01,0x0c,0xe0,0x04,0x00,
-	0x80,0x00,0x02,0x00,0x02,0x01,0x00,0x01, 0x00,
+	0x07,
+	0xff,
+	0x11,	// 17 bytes
+	0x02,
+	0x00,
+	0x00,
+	0x82,
+	0x00,
+
+	0x14,	// source SAP
+	0x00,
+	0x02,	// MPI address
+	0x01,
+	0x0c,	// 12 bytes follow
+	0xe0,0x04,0x00,0x80,
+	0x00,0x02,
+	0x00,0x02,
+	0x01,	// communication type?
+	0x00,
+	0x01,	// 6 when routed
+	0x00,
 };
 
+	uc chal8R[]={   //Routing
+	0x07,
+	0xff,
+	0x1b,	// 27 bytes, 10 more
+	0x02,
+	0x00,
+	0x00,
+	0x82,
+	0x00,
+	0x14,	// source SAP
+	0x00,	
+	0x02,	// MPI address
+	0x01,
+	0x16,	// 22 bytes follow (when routing to MPI, 25 when routing to IP)
+	0xe0,0x04,0x00,0x80,
+	0x00,0x02,
+	0x01,0x0c,
+	0x01,	// dc->CommunicationType, // communication type? I do NOT think so.
+	0x00,
+	0x06,	// 6 byte subnet ID
+	0x01,	// 1 byte PLC address	my guess
+	0x02,	// 2 byte something else
+	0x01,0x52,0x00,0x00,0x00,0x13,	// subnet ID
+	0x01,				// PLC address, MPI or Profibus or IP
+	0x01,	// comunication type?
+	0x02,	// rack,slot ?
+	0,0,0
+	};
+
 /* This is the correct response. I just inserted a "don't care" to make it work with latest 
    IBH simulator. Better fix the simulator!
 us resp7[]={
@@ -5255,9 +5149,13 @@
 	0x04,0x00,0x80,0x00,0x02,0x00,0x02,0x01, 0x00,0x01,0x00,
 };
 */
+
+// from routing, target MPI
 us resp7[]={
-	0xff,0x07,0x13,0x00,0x00,0x00,0xc2,0x02, 0x115,0x114,0x102,0x100,0x00,0x22,0x0c,0xd0,
-	0x04,0x00,0x80,0x00,0x02,0x00,0x102,0x01, 0x00,0x01,0x00,
+	0xFF,0x07,0x11D,0x00,0x00,0x00,0xC2,0x02, 0x114,0x12E,0x102,0x100,0x00,0x22,0x116,0xD0,
+	0x04,0x00,0x80,
+//	0x01,0x0C,0x00,0x02,0x06, 0x01,0x02,0x01,0x52,0x00,0x00,0x00,0x13,
+//	0x102,0x101,0x102,0x101,0x100,
 };
 
 uc chal011[]={
@@ -5277,6 +5175,7 @@
     int a, retries;
     PDU p1;
     uc b[daveMaxRawLen];
+    uc * pcha;
     dc->iface->timeout=500000;
     dc->iface->localMPI=0;
     dc->ibhSrcConn=20-1;
@@ -5292,10 +5191,50 @@
     } while ((b[9]!=0) && (retries<10));
     if (daveDebug & daveDebugConnect) 
 	LOG2("_daveInitStepIBH 4:%d\n",a); if (a>3) /* !!! */ return -4;;
-    chal8[10]=dc->MPIAdr;	
+//    if (!dc->routing) {
+	chal8[8]=dc->ibhSrcConn;
+	chal8[10]=dc->MPIAdr;
+//    } else {
+	chal8R[8]=dc->ibhSrcConn;
+	chal8R[10]=dc->MPIAdr;
+//    }
+
 //    LOG2("setting MPI %d\n",dc->MPIAdr);
-    chal8[8]=dc->ibhSrcConn;
-    a=_daveInitStepIBH(dc->iface, chal8,sizeof(chal8),resp7,sizeof(resp7),b);
+    if (!dc->routing) {
+	a=_daveInitStepIBH(dc->iface, chal8,sizeof(chal8),resp7,sizeof(resp7),b);
+    } else {
+	pcha=chal8R+2;
+	*pcha=26+dc->routingData.PLCadrsize;
+
+	pcha=chal8R+12;
+	*pcha=21+dc->routingData.PLCadrsize;
+	
+	pcha=chal8R+20;
+	*pcha=11+dc->routingData.PLCadrsize;
+
+	pcha=chal8R+24;
+	*pcha=dc->routingData.PLCadrsize;
+
+	pcha=chal8R+26;
+//	_daveAddSubnet(dc, &pcha);
+	
+	*pcha=(dc->routingData.subnetID1) / 0x100; pcha++;
+	*pcha=(dc->routingData.subnetID1) % 0x100; pcha++;
+	*pcha=(dc->routingData.subnetID2) / 0x100; pcha++;
+	*pcha=(dc->routingData.subnetID2) % 0x100; pcha++;
+	*pcha=(dc->routingData.subnetID3) / 0x100; pcha++;
+	*pcha=(dc->routingData.subnetID3) % 0x100; pcha++;
+
+	memcpy(pcha, dc->routingData.PLCadr, dc->routingData.PLCadrsize);
+	pcha+=dc->routingData.PLCadrsize;
+	*pcha=dc->communicationType;
+        *pcha=(dc->slot | dc->rack<<5);
+	
+//	a=_daveInitStepIBH(dc->iface, chal8R, sizeof(chal8R), resp7R, sizeof(resp7R), b);
+//	a=_daveInitStepIBH(dc->iface, chal8R, sizeof(chal8R)-4+dc->routingData.PLCadrsize, resp7R, sizeof(resp7R), b);
+//	a=_daveInitStepIBH(dc->iface, chal8R, sizeof(chal8R)-4+dc->routingData.PLCadrsize, resp7R, 19, b);
+	a=_daveInitStepIBH(dc->iface, chal8R, sizeof(chal8R)-4+dc->routingData.PLCadrsize, resp7, sizeof(resp7), b);
+    }
     dc->ibhDstConn=b[9];
     if (daveDebug & daveDebugConnect) 
 	LOG3("_daveInitStepIBH 5:%d connID: %d\n",a, dc->ibhDstConn); if (a>3) return -5;
@@ -5679,7 +5618,7 @@
     }
     dc->AnswLen=len;
     return res;
-}    
+}
 
 int DECL2 daveSetPLCTime(daveConnection * dc,uc * ts) {
     int res, len;
@@ -5725,6 +5664,7 @@
     localtime_r(&(t1.tv_sec),&systime);
     t1.tv_usec/=100;		//tenth of miliseconds from microseconds
 //    ts[1]=daveToBCD(systime.tm_year/100+19);
+    ts[1]=daveToBCD(systime.tm_year / 100); // fix 2010 bug is this line necessary? ok?
     ts[2]=daveToBCD(systime.tm_year % 100); // fix 2010 bug
     ts[3]=daveToBCD(systime.tm_mon+1);
     ts[4]=daveToBCD(systime.tm_mday);
@@ -5755,6 +5695,7 @@
     WORD wSecond;
     WORD wMilliseconds;
 */
+    ts[1]=daveToBCD(t1.wYear / 100); // fix 2010 bug
     ts[2]=daveToBCD(t1.wYear % 100); // fix 2010 bug
     ts[3]=daveToBCD(t1.wMonth);
     ts[4]=daveToBCD(t1.wDay);
@@ -5917,7 +5858,7 @@
     if (daveDebug & daveDebugExchange)
 	    LOG3("%s daveReqTrans %d\n", dc->iface->name, trN);
     _daveSendSingle(dc->iface, STX);
-    res=_daveReadChars2(dc->iface, b1, /*dc->iface->timeout,*/ sizeof(__daveT1006)/2);
+    res=dc->iface->ifread(dc->iface, b1, /*dc->iface->timeout,*/ sizeof(__daveT1006)/2);
     if (daveDebug & daveDebugByte)
 	_daveDump("2got",b1, res);
     if (_daveMemcmp(__daveT1006, b1, sizeof(__daveT1006)/2)) {
@@ -5932,7 +5873,7 @@
 	return -2;
     }
     _daveSendDLEACK(dc->iface);
-    _daveReadChars2(dc->iface, b1, /*dc->iface->timeout,*/ sizeof(__daveT161003)/2);
+    dc->iface->ifread(dc->iface, b1, /*dc->iface->timeout,*/ sizeof(__daveT161003)/2);
     if (daveDebug & daveDebugByte)
 	_daveDump("1got",b1, res);
     if (_daveMemcmp(__daveT161003, b1, sizeof(__daveT161003)/2)) {    
@@ -5958,7 +5899,7 @@
 //	return -1;
     }
     _daveSendDLEACK(dc->iface);
-    res=_daveReadChars2(dc->iface, b1, /*dc->iface->timeout,*/ sizeof(__daveT121003)/2);
+    res=dc->iface->ifread(dc->iface, b1, /*dc->iface->timeout,*/ sizeof(__daveT121003)/2);
     if (daveDebug & daveDebugByte)
 	_daveDump("3got",b1, res);
     if (_daveMemcmp(__daveT121003, b1, sizeof(__daveT121003)/2)) {
@@ -6008,8 +5949,8 @@
 	    LOG2("trN %d done\n",trN);
     }
 //    _daveSendDLEACK(dc->iface);
-//    res=_daveReadChars2(dc->iface, b1, /*dc->iface->timeout,*/ 2000 /*sizeof(__daveT1006)/2*/);
-    res=_daveReadChars2(dc->iface, b1, /*dc->iface->timeout,*/ sizeof(__daveT1006)/2);
+//    res=dc->iface->ifread(dc->iface, b1, /*dc->iface->timeout,*/ 2000 /*sizeof(__daveT1006)/2*/);
+    res=dc->iface->ifread(dc->iface, b1, /*dc->iface->timeout,*/ sizeof(__daveT1006)/2);
     if (daveDebug & daveDebugByte)
 	_daveDump("4 got:",b1, res);
     if (_daveMemcmp(__daveT1006, b1, sizeof(__daveT1006)/2)) {
@@ -6025,7 +5966,8 @@
         _daveSendDLEACK(dc->iface);
 	res=0;
 	do {
-    	    i=_daveReadChars2(dc->iface, dc->msgIn+res, /*100*dc->iface->timeout,*/ daveMaxRawLen-res);
+//	    i=dc->iface->ifread(dc->iface, dc->msgIn+res, /*100*dc->iface->timeout,*/ daveMaxRawLen-res);
+	    i=dc->iface->ifread(dc->iface, dc->msgIn+res, /*100*dc->iface->timeout,*/ 1);
 	    res+=i;
 	    if (daveDebug & daveDebugByte)
 		_daveDump("5 got:",dc->msgIn, res);
@@ -6055,7 +5997,7 @@
 	    return -5;
 	}
 	_daveSendSingle(dc->iface,STX);
-	res=_daveReadChars2(dc->iface, b1, /*dc->iface->timeout,*/ sizeof(__daveT1006)/2);
+	res=dc->iface->ifread(dc->iface, b1, /*dc->iface->timeout,*/ sizeof(__daveT1006)/2);
 	_daveDump("got:",b1, res);
 	if (_daveMemcmp(__daveT1006, b1, sizeof(__daveT1006)/2)) {	
 	    LOG2("%s 8 *** no DLE,ACK in special Exchange request.\n", dc->iface->name);
@@ -6063,7 +6005,7 @@
         }
         _daveSendWithDLEDup(dc->iface,b+4,len);
 	
-	res=_daveReadChars2(dc->iface, b1, /*dc->iface->timeout,*/ sizeof(__daveT1006)/2);
+	res=dc->iface->ifread(dc->iface, b1, /*dc->iface->timeout,*/ sizeof(__daveT1006)/2);
 	_daveDump("got:",b1, res);
 	if (_daveMemcmp(__daveT1006, b1, sizeof(__daveT1006)/2)) {
 //        if (!_daveTestChars(dc->iface, __davet1006, 2)) {
@@ -6373,6 +6315,7 @@
     if (daveDebug & daveDebugByte) {
 	_daveDump("header:",buffer, 80);
 	_daveDump("data:",buffer+80, fdr->payloadLength);
+	_daveDump("data:",buffer+80, fdr->payloadLength);
     }	
     return res;	
 }    
@@ -6445,7 +6388,7 @@
     _daveSetupReceivedPDU(dc, &pu2);
     if (daveGetDebug() & daveDebugPDU)
 	_daveDumpPDU(&pu2);
-    
+
     memset(fdr,0,560);
     fdr->user= 0;
     fdr->field6= 64;
@@ -6463,12 +6406,12 @@
 //    if (daveDebug & daveDebugConnect) 
 	LOG2("\n*** Partner offered PDU length: %d\n\n",dc->maxPDUlength);
     return res;
-    
-/*    
+
+/*
     memset((uc*)(&giveBack)+80,0,480);
     giveBack.payloadLength= 480;
     return _daveNegPDUlengthRequest(dc, &pu1);
-*/    
+*/
 }
 
 int DECL2 _daveSendMessageS7online(daveConnection *dc, PDU *p) {
@@ -6492,7 +6435,53 @@
     SCP_receive((int)(dc->iface->fd.rfd), 0xFFFF, &datalen, sizeof(S7OexchangeBlock), buffer);
 //    daveSCP_receive(dc->iface->fd.rfd, dc->msgIn);
     return 0;
-}    
+}
+
+int DECL2 _daveDisconnectPLCS7online (daveConnection * dc) {
+    int co,er,a;
+    S7OexchangeBlock reqBlock;
+    S7OexchangeBlock* fdr;
+    uc b1[sizeof(S7OexchangeBlock)];
+
+
+    fdr=&reqBlock;
+
+    memset(fdr,0,140);
+    fdr->user= 102;
+    fdr->priority= 0;
+    
+    fdr->field6= 64;
+    fdr->field7= 12;
+    fdr->field8= 255;
+    fdr->payloadLength= 0;
+    fdr->field10= 0x1;
+//    fdr->functionCode= 0x1;
+//    fdr->id3= 0x1;
+    co=0;
+    do{
+	a= _daveSCP_send((int)(dc->iface->fd.wfd), (char *) &reqBlock);
+	er=SCP_get_errno();
+	printf("res 7:%d %d\n",a,er);
+#ifdef BCCWIN
+	Sleep(100);
+#endif
+#ifdef LINUX
+	usleep(100000);
+#endif
+	co++;
+    }	while ((a!=0)&&(co<10));
+//    daveSCP_receive((int)(dc->iface->fd.rfd), b1);
+    
+    co=0;
+    do{
+	a=daveSCP_receive((int)(dc->iface->fd.rfd), b1);
+	er=SCP_get_errno();
+	printf("result 7:%d %d\n",a,er);
+	co++;
+    } while ((a!=0)&&(co<10));
+
+}
+
 
 int DECL2 _daveGetResponseS7online(daveConnection *dc) {
     int a;
@@ -6519,7 +6508,7 @@
     memset(fdr,0,140);
     fdr->user= 102;
     fdr->priority= 1;
-    fdr->field6= 34;
+    fdr->field6= 34; // 0x22 is FDL
     fdr->field8= 16642;
     fdr->payloadLength= 60;
     fdr->application_block_service= 0x28;
@@ -6622,55 +6611,19 @@
 #endif
 
 #ifdef NET
-#ifdef HAVE_SELECT
 /*
     Read one complete packet. The bytes 0 and 1 contain length information.
     This version needs a socket filedescriptor that is set to O_NONBLOCK or
     it will hang, if there are not enough bytes to read.
     The advantage may be that the timeout is not used repeatedly.
 */
-int DECL2 _daveReadMPINLpro(daveInterface * di,uc *b) {
-	int res,length;
-	fd_set FDS;
-	struct timeval t;
-	FD_ZERO(&FDS);
-	FD_SET(di->fd.rfd, &FDS);
-	
-	t.tv_sec = di->timeout / 1000000;
-	t.tv_usec = di->timeout % 1000000;
-	if (select(di->fd.rfd + 1, &FDS, NULL, NULL, &t) <= 0) {
-	    if (daveDebug & daveDebugByte) LOG1("timeout in ReadMPINLpro.\n");
-	    return daveResTimeout;
-	} else {
-	res=read(di->fd.rfd, b, 2);
-        if (res<2) {
-	    if (daveDebug & daveDebugByte) {
-		LOG2("res %d ",res);
-		_daveDump("readISOpacket: short packet", b, res);
-	    }
-	    return daveResShortPacket; /* short packet */
-	}
-	length=b[1]+0x100*b[0];
-	res+=read(di->fd.rfd, b+2, length);
-	if (daveDebug & daveDebugByte) {
-	    LOG3("readMPINLpro: %d bytes read, %d needed\n",res, length);
-	    _daveDump("readMPINLpro: packet", b, res);    
-	}
-	return (res);
-    }
-}
-#endif /* HAVE_SELECT */
 
-#ifdef BCCWIN
 int DECL2 _daveReadMPINLpro(daveInterface * di,uc *b) {
 	int res,i,length;
-	i=recv((SOCKET)(di->fd.rfd), b, 2, 0);
+	i=_daveTimedRecv(di, b, 2);
 	res=i;
-	if (res <= 0) {
-	    if (daveDebug & daveDebugByte) LOG1("timeout in ReadMPINLpro.\n");
-	    return daveResTimeout;
-	} else {
-    	    if (res<2) {
+	if (res <= 0) return daveResTimeout;
+	if (res<2) {
 	    if (daveDebug & daveDebugByte) {
 		LOG2("res %d ",res);
 		_daveDump("readISOpacket: short packet", b, res);
@@ -6678,21 +6631,18 @@
 	    return daveResShortPacket; /* short packet */
 	}
 	length=b[1]+0x100*b[0];
-	i=recv((SOCKET)(di->fd.rfd), b+2, length, 0);
+	i=_daveTimedRecv(di, b+2, length);
 	res+=i;
 	if (daveDebug & daveDebugByte) {
 	    LOG3("readMPINLpro: %d bytes read, %d needed\n",res, length);
-	    _daveDump("readMPIpro: packet", b, res);    
+	    _daveDump("readMPIpro: packet", b, res);
 	}
 	return (res);
-    }
 }
-
-#endif /* */
 #endif
 
 
-/* 
+/*
     This initializes the MPI adapter. Andrew's version.
 */
 
@@ -6747,27 +6697,8 @@
     
 }
 
-/*
-int DECL2 _daveSendISOPacket(daveConnection * dc, int size) {
-    unsigned long i;
-    size+=4;
-    *(dc->msgOut+3)=size % 0x100;	//was %0xFF, certainly a bug	
-    *(dc->msgOut+2)=size / 0x100;
-    *(dc->msgOut+1)=0;
-    *(dc->msgOut+0)=3;
-    if (daveDebug & daveDebugByte) 
-	_daveDump("send packet: ",dc->msgOut,size);
-#ifdef HAVE_SELECT
-    daveWriteFile(dc->iface->fd.wfd, dc->msgOut, size, i);
-#endif    
-#ifdef BCCWIN
-    send((unsigned int)(dc->iface->fd.wfd), dc->msgOut, size, 0);
-#endif
-    return 0;
-}
-*/
 
-/* 
+/*
     This sends a string after doubling DLEs in the String
     and adding DLE,ETX and bcc.
 */
@@ -6820,15 +6751,44 @@
     (or reused for the same PLC ?)
 */
 int DECL2 _daveConnectPLCNLpro(daveConnection * dc) {
-    int res;
+    int res, len;
     PDU p1;
+    uc * pcha;
+
     uc b4[]={
-	0x04,0x80,0x80,0x0D,0x00,0x14,0xE0,0x04,
-	0x00,0x80,0x00,0x02,
-	0x00,
-	0x02,
-	0x01,0x00,
-	0x01,0x00,
+		0x04, //00
+		0x80, //01 (0x80 | MPI)
+		0x80, //02
+		0x0D, //03
+		0x00, //04
+		0x14, //05
+		
+		0xE0, //06
+		0x04, //07
+		0x00, //08
+		0x80, //09
+		0x00, //10
+		0x02, //11
+		0x00, //12 //01 ??? Routing???
+		0x02, //13 //02 = no routing / 0c = Routing to MPI / 0f Routing to IP (Bytecount to End-2)
+		1, 	//
+		0, 	//
+		1,	//
+		0, 	//17 //End of Telegram when no Routing (00) / 01 Routing to MPI / 04 Routing to IP
+		0x00, //18
+		0x00, //19 subnet1
+		0x00, //20 subnet1
+		0x00, //21
+		0x00, //22
+		0x00, //23 subnet2
+		0x00, //24 subnet2
+		
+		0x00, //25 PLC address
+		0x00, //26 
+		0x00, //27 
+		0x00, //28 
+		0x02, //29 Communication type
+		0x04  //30 Rack, Slot
     };
 
     us t4[]={
@@ -6848,9 +6808,35 @@
     b4[1]|=dc->MPIAdr;	
     b4[5]=dc->connectionNumber; // 1/10/05 trying Andrew's patch
     
+    len=18;
     t4[1]|=dc->MPIAdr;	
     t5[1]|=dc->MPIAdr;	
-    _daveInitStepNLpro(dc->iface, 1, b4, sizeof(b4),"connectPLC(1)", dc->msgIn);
+
+    pcha=b4+16;
+    if(dc->routing) {
+    
+	pcha=b4+12;
+	*pcha=1; pcha++;
+	*pcha=11+dc->routingData.PLCadrsize; 
+	pcha=b4+16;
+	*pcha=6; pcha++;
+	*pcha=dc->routingData.PLCadrsize; pcha++;
+	*pcha=2; pcha++;
+
+	*pcha=(dc->routingData.subnetID1) / 0x100; pcha++;
+	*pcha=(dc->routingData.subnetID1) % 0x100; pcha++;
+	*pcha=(dc->routingData.subnetID2) / 0x100; pcha++;
+	*pcha=(dc->routingData.subnetID2) % 0x100; pcha++;
+	*pcha=(dc->routingData.subnetID3) / 0x100; pcha++;
+	*pcha=(dc->routingData.subnetID3) % 0x100; pcha++;
+	memcpy(pcha, dc->routingData.PLCadr, dc->routingData.PLCadrsize);
+	pcha+=dc->routingData.PLCadrsize;
+	len=27+dc->routingData.PLCadrsize; 
+	
+    }
+    *pcha=dc->communicationType; pcha++;
+	*pcha=dc->rack; pcha++;
+    _daveInitStepNLpro(dc->iface, 1, b4, len, "connectPLC(1)", dc->msgIn);
     
     // first 2 bytes of msgIn[] contain packet length
     dc->connectionNumber2=dc->msgIn[2+5]; // 1/10/05 trying Andrew's patch
@@ -7014,7 +7000,7 @@
     if (daveDebug & daveDebugInitAdapter) 
 	LOG2("%s daveDisconnectAdapter() step 2.\n", di->name);	
     _daveSendSingle(di, DLE);
-    _daveReadChars2(di, b1, daveMaxRawLen);
+    dc->iface->ifread(di, b1, daveMaxRawLen);
 //    _daveReadChars(di, b1, tmo_normal, daveMaxRawLen);
     _daveSendSingle(di, DLE);
     if (daveDebug & daveDebugInitAdapter) 
@@ -7142,4 +7128,12 @@
     07/10/09  Changed readISOpacket for Win32 to select() before recv().
     07/10/09  Added daveCopyRAMtoROM
     07/11/09  Changed calculation of netLen in doUpload()
+Version 0.8.5
+    05/17/13  return bad results from daveBuildAndSendPDU() in several places
+    05/17/13  removed old code for table based CRC calculation
+    05/17/13  added a disconnect function for S7online
+    05/17/13  added support for transport of long PDUs split into multiple IBH packets
+    05/18/13  added support for transport of long PDUs split into multiple ISO packets
+    05/18/13  added routing support
+    05/19/13  added communication type (PG, OP, S7-Basic)
 */
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/nodave.h ../libnodave-0.8.5/nodave.h
--- ../libnodave-0.8.4.6/nodave.h	2013-05-18 13:44:59.000000000 +0200
+++ ../libnodave-0.8.5/nodave.h	2013-10-19 14:31:11.000000000 +0200
@@ -42,7 +42,7 @@
 typedef struct dost {
     int rfd;
     int wfd;
-//    int connectionType;
+//    int connectionType;	// remember whether this is a socket or a serial connection or a handle or whatever
 } _daveOSserialType;
 #include <stdlib.h>
 #define tmotype int
@@ -51,6 +51,7 @@
 
 #ifdef BCCWIN
 #define WIN32_LEAN_AND_MEAN
+#include <winsock2.h>	// according to Jochen Kühner, this is needed to compile on Win64
 #include <windows.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -83,7 +84,7 @@
 typedef struct dost {
     int rfd;
     int wfd;
-    int connectionType;
+//    int connectionType;
 } _daveOSserialType;
 #define OS_KNOWN
 #endif
@@ -96,7 +97,7 @@
 typedef struct dost {
     int rfd;
     int wfd;
-    int connectionType;
+//    int connectionType;
 } _daveOSserialType;
 #define tmotype long
 #define OS_KNOWN
@@ -132,7 +133,6 @@
 
 #define daveProtoISOTCP	122	/* ISO over TCP */
 #define daveProtoISOTCP243 123	/* ISO over TCP with CP243 */
-#define daveProtoISOTCPR 124	/* ISO over TCP with Routing */
 
 #define daveProtoMPI_IBH 223	/* MPI with IBH NetLink MPI to ethernet gateway */
 #define daveProtoPPI_IBH 224	/* PPI with IBH NetLink PPI to ethernet gateway */
@@ -143,6 +143,14 @@
 					/* defined call back functions. */
 
 /*
+    Communication types
+*/
+#define davePGCommunication 1	/* communication with programming device (PG) (default in Libnodave) */
+#define daveProgrammerCommunication 1	/* communication with programming device (PG) (default in Libnodave) */
+#define daveOPCommunication 2	/* communication with operator panel (OP)) */
+#define daveS7BasicCommunication 3	/* communication with another CPU ? */
+
+/*
  *    ProfiBus speed constants:
 */
 #define daveSpeed9k     0
@@ -154,7 +162,7 @@
 #define daveSpeed93k    6
 
 /*
-    Some MPI function codes (yet unused ones may be incorrect).
+    Some S7 communication function codes (yet unused ones may be incorrect).
 */
 #define daveFuncOpenS7Connection	0xF0
 #define daveFuncRead			0x04
@@ -454,10 +462,20 @@
     daveS5AreaInfo * first;
 } daveS5cache;
 
-/* 
+
+typedef struct _daveRoutingData {
+	int connectionType;
+	int destinationType; 	// destinationIsIP=DestinationIsIP;
+	int subnetID1;
+	int subnetID2;
+	int subnetID3;
+	int PLCadrsize;
+	uc  PLCadr[4];		// currently, IP is maximum. Maybe there could be MAC adresses for Industrial Ethernet?
+} daveRoutingData;
+
+/*
     This holds data for a PLC connection;
 */
-
 struct _daveConnection {
     int AnswLen;	/* length of last message */
     uc * resultPointer;	/* used to retrieve single values from the result byte array */
@@ -481,14 +499,50 @@
     uc	packetNumber;	/* packetNumber in transport layer */
     void * hook;	/* used in CPU/CP simulation: pointer to the rest we have to send if message doesn't fit in a single packet */
     daveS5cache * cache; /* used in AS511: We cache addresses of memory areas and datablocks here */
+    int TPDUsize; 		// size of TPDU for ISO over TCP
+    int partPos;  		// remember position for ISO over TCP fragmentation
+    int routing;		// nonzero means routing enabled
+    int communicationType;		// (1=PG Communication,2=OP Communication,3=Step7Basic Communication)
+    daveRoutingData routingData;
 }; 
 
+EXPORTSPEC void DECL2 daveSetRoutingDestination(daveConnection * dc, int subnet1,int subnet3,int adrsize, uc* plcadr);
 /* 
+	    void * Destination, 
+	    int DestinationIsIP, 
+	    int rack, int slot, 
+	    int routing, 
+	    int routingSubnetFirst, 
+	    int routingSubnetSecond, 
+	    int routingRack, 
+	    int routingSlot, 
+	    void * routingDestination, 
+	    int routingDestinationIsIP, 
+	    int ConnectionType, 
+	    int routingConnectionType) {
+*/
+
+EXPORTSPEC void DECL2 daveSetCommunicationType(daveConnection * dc,  int communicationType);
+/*
+EXPORTSPEC daveConnection * DECL2 daveNewEonnection(daveInterface * di, 
+	    void * Destination, 
+	    int DestinationIsIP, 
+	    int rack, int slot, 
+	    int routing, 
+	    int routingSubnetFirst, 
+	    int routingSubnetSecond, 
+	    int routingRack, 
+	    int routingSlot, 
+	    void * routingDestination, 
+	    int routingDestinationIsIP, 
+	    int ConnectionType, 
+	    int routingConnectionType) {
+*/
+/*
     Setup a new connection structure using an initialized
     daveInterface and PLC's MPI address.
 */
-EXPORTSPEC 
-daveConnection * DECL2 daveNewConnection(daveInterface * di, int MPI,int rack, int slot);
+EXPORTSPEC daveConnection * DECL2 daveNewConnection(daveInterface * di, int MPI,int rack, int slot);
 
 
 typedef struct {
@@ -531,6 +585,20 @@
     us dlen;	/* length of data which follow the parameters */
     uc result[2]; /* only present in type 2 and 3 headers. This contains error information. */
 } PDUHeader;
+
+/*
+    same as above, but made up of single bytes only, so that every single byte can be adressed separately
+*/
+typedef struct {
+    uc P;	/* allways 0x32 */
+    uc type;	/* Header type, one of 1,2,3 or 7. type 2 and 3 headers are two bytes longer. */
+    uc a,b;	/* currently unknown. Maybe it can be used for long numbers? */
+    uc numberHi,numberLo;	/* A number. This can be used to make sure a received answer */
+		/* corresponds to the request with the same number. */
+    uc plenHi,plenLo;	/* length of parameters which follow this header */
+    uc dlenHi,dlenLo;	/* length of data which follow the parameters */
+    uc result[2]; /* only present in type 2 and 3 headers. This contains error information. */
+} PDUHeader2;
 /*
     set up the header. Needs valid header pointer in the struct p points to.
 */
@@ -1100,8 +1168,8 @@
     us          payloadLength;
     us		payloadStart;
     uc		unknown2[12];
-    uc		field10; 
-    us		id3; 
+    uc		field10;
+    us		id3;
     short 	application_block_service;
     uc		unknown4[2];
     uc          field13;
@@ -1115,6 +1183,7 @@
 EXPORTSPEC int DECL2 _daveSCP_send(int fd, uc * reqBlock);
 EXPORTSPEC int DECL2 _daveConnectPLCS7online (daveConnection * dc);
 EXPORTSPEC int DECL2 _daveSendMessageS7online(daveConnection * dc, PDU *p);
+EXPORTSPEC int DECL2 _daveDisconnectPLCS7online (daveConnection * dc);
 EXPORTSPEC int DECL2 _daveGetResponseS7online(daveConnection * dc);
 EXPORTSPEC int DECL2 _daveExchangeS7online(daveConnection * dc, PDU * p);
 EXPORTSPEC int DECL2 _daveListReachablePartnersS7online (daveInterface * di, char * buf);
@@ -1196,4 +1265,7 @@
     09/11/05  added read/write functions for long blocks of data.	      
     09/17/05  incorporation of S5 functions
     09/18/05  implemented conversions from and to S5 KG format (old, propeiatary floating point format).
+Version 0.8.5:
+    05/17/13  added include winsock2 for 46 bit compatibility.
+    05/17/13  added conType field to daveOSserialType
 */
Nur in ../libnodave-0.8.5: nodave.o.
Nur in ../libnodave-0.8.5: nodave.obj.
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/nodavesimple.h ../libnodave-0.8.5/nodavesimple.h
--- ../libnodave-0.8.4.6/nodavesimple.h	2009-07-10 23:30:08.000000000 +0200
+++ ../libnodave-0.8.5/nodavesimple.h	2013-08-14 23:26:28.000000000 +0200
@@ -45,11 +45,13 @@
 typedef struct {
     int rfd;
     int wfd;
+//    int conType;	// remember whether this is a socket or a serial connection or a handle or whatever
 } _daveOSserialType;
 #include <stdlib.h>
 #else    
 #ifdef BCCWIN
 #define WIN32_LEAN_AND_MEAN
+#include <winsock2.h>
 #include <windows.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -63,6 +65,7 @@
 typedef struct {
     HANDLE rfd;
     HANDLE wfd;
+//    int conType;
 } _daveOSserialType;
 #else
 #error Fill in what you need for your OS or API.
@@ -646,4 +649,7 @@
     04/10/05  first version.
     09/11/05  added read/write functions for long blocks of data.
     10/26/07  fixed __cplusplus
+Version 0.8.5:
+    05/17/13  added include winsock2 for 46 bit compatibility.
+    05/17/13  added conType field to daveOSserialType
 */
Nur in ../libnodave-0.8.5: openS7online.diff.
Nur in ../libnodave-0.8.5: openS7online.obj.
Nur in ../libnodave-0.8.5: openSocket.o.
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/openSocketw.c ../libnodave-0.8.5/openSocketw.c
--- ../libnodave-0.8.4.6/openSocketw.c	2011-02-28 01:42:21.000000000 +0100
+++ ../libnodave-0.8.5/openSocketw.c	2013-05-21 12:17:34.000000000 +0200
@@ -136,13 +136,13 @@
 	if (daveDebug & daveDebugOpen) {
 	    LOG2(ThisModule "connect Socket error: %s \n", strerror(errno));
 	}    
-//	socketClose(fd);
 	closesocket(fd);
+	WSACleanup();	// patch from Klaus Albert
 	fd = 0;
     } else {
-//	if (daveDebug & daveDebugOpen) {
+	if (daveDebug & daveDebugOpen) {
 	    LOG2(ThisModule "Connected to host: %s \n", peer);
-//	}    
+	}    
 /*
 	Need this, so we can read a packet with a single read call and make
 	read return if there are too few bytes.
@@ -169,6 +169,7 @@
 
 __declspec (dllexport) int __stdcall closeSocket(SOCKET h) {
     return closesocket(h);
+    WSACleanup();	// patch from Klaus Albert
 }
 
 #endif
@@ -179,4 +180,7 @@
     07/19/2004  removed unused vars.
 Version 0.8.4.5    
     07/10/09  	Added closeSocket()
+Version 0.8.5    
+    05/17/2013  	Suppress message if debug mode is not set
+    05/20/2013  	added WSACleanup(), patch from Klaus Albert
 */
Nur in ../libnodave-0.8.5: openSocketw.obj.
Nur in ../libnodave-0.8.5: output1.
Nur in ../libnodave-0.8.5: output2.
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/pascal/build.linux ../libnodave-0.8.5/pascal/build.linux
--- ../libnodave-0.8.4.6/pascal/build.linux	2007-01-08 21:30:12.000000000 +0100
+++ ../libnodave-0.8.5/pascal/build.linux	2013-05-19 15:45:43.000000000 +0200
@@ -1,6 +1,6 @@
-ppc386 $1 -k/lib/libc.so.6 testPPI.pas
-#ppc386 $1 -k/lib/libc.so.6 -vc testISO_TCP.pas
-ppc386 $1 -k/lib/libc.so.6 testISO_TCP.pas
-ppc386 $1 -k/lib/libc.so.6 testIBH.pas
-ppc386 $1 -k/lib/libc.so.6 testPPI_IBH.pas
-ppc386 $1 -k/lib/libc.so.6 testMPI.pas	
\ Kein Zeilenumbruch am Dateiende.
+ppc386 $1 -k/lib/i386-linux-gnu/libc.so.6 testPPI.pas
+#ppc386 $1 -k/lib/i386-linux-gnu/libc.so.6 -vc testISO_TCP.pas
+ppc386 $1 -k/lib/i386-linux-gnu/libc.so.6 testISO_TCP.pas
+ppc386 $1 -k/lib/i386-linux-gnu/libc.so.6 testIBH.pas
+ppc386 $1 -k/lib/i386-linux-gnu/libc.so.6 testPPI_IBH.pas
+ppc386 $1 -k/lib/i386-linux-gnu/libc.so.6 testMPI.pas
Binärdateien ../libnodave-0.8.4.6/pascal/nodave.o and ../libnodave-0.8.5/pascal/nodave.o sind verschieden.
Nur in ../libnodave-0.8.4.6/pascal: nodave.ow.
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/pascal/nodave.pas ../libnodave-0.8.5/pascal/nodave.pas
--- ../libnodave-0.8.4.6/pascal/nodave.pas	2009-07-11 21:15:52.000000000 +0200
+++ ../libnodave-0.8.5/pascal/nodave.pas	2013-05-19 15:44:10.000000000 +0200
@@ -17,7 +17,7 @@
    IBH/MHJ-NetLink or CPs 243, 343 and 443
    or VIPA Speed7 with builtin ethernet support.
 
-   (C) Thomas Hergenhahn (thomas.hergenhahn@web.de) 2002..2005
+   (C) Thomas Hergenhahn (thomas.hergenhahn@web.de) 2002..2013
 
    Libnodave is free software; you can redistribute it and/or modify
    it under the terms of the GNU Library General Public License as published by
Binärdateien ../libnodave-0.8.4.6/pascal/nodave.ppu and ../libnodave-0.8.5/pascal/nodave.ppu sind verschieden.
Nur in ../libnodave-0.8.4.6/pascal: nodave.ppw.
Nur in ../libnodave-0.8.5/pascal: oldlinux.o.
Nur in ../libnodave-0.8.5/pascal: oldlinux.pas.
Nur in ../libnodave-0.8.5/pascal: oldlinux.ppu.
Binärdateien ../libnodave-0.8.4.6/pascal/testIBH and ../libnodave-0.8.5/pascal/testIBH sind verschieden.
Nur in ../libnodave-0.8.4.6/pascal: testibh.exe.
Binärdateien ../libnodave-0.8.4.6/pascal/testIBH.o and ../libnodave-0.8.5/pascal/testIBH.o sind verschieden.
Nur in ../libnodave-0.8.4.6/pascal: testibh.ow.
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/pascal/testIBH.pas ../libnodave-0.8.5/pascal/testIBH.pas
--- ../libnodave-0.8.4.6/pascal/testIBH.pas	2007-01-09 00:23:26.000000000 +0100
+++ ../libnodave-0.8.5/pascal/testIBH.pas	2013-05-19 15:44:29.000000000 +0200
@@ -7,7 +7,7 @@
  * This is alpha software. Use entirely on your own risk.             * 
  **********************************************************************
  
- (C) Thomas Hergenhahn (thomas.hergenhahn@web.de) 2002, 2003.
+ (C) Thomas Hergenhahn (thomas.hergenhahn@web.de) 2002...2013.
 
  This is free software; you can redistribute it and/or modify
  it under the terms of the GNU Library General Public License as published by
Binärdateien ../libnodave-0.8.4.6/pascal/testISO_TCP and ../libnodave-0.8.5/pascal/testISO_TCP sind verschieden.
Nur in ../libnodave-0.8.4.6/pascal: testiso_tcp.exe.
Binärdateien ../libnodave-0.8.4.6/pascal/testISO_TCP.o and ../libnodave-0.8.5/pascal/testISO_TCP.o sind verschieden.
Nur in ../libnodave-0.8.4.6/pascal: testiso_tcp.ow.
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/pascal/testISO_TCP.pas ../libnodave-0.8.5/pascal/testISO_TCP.pas
--- ../libnodave-0.8.4.6/pascal/testISO_TCP.pas	2007-01-09 00:23:26.000000000 +0100
+++ ../libnodave-0.8.5/pascal/testISO_TCP.pas	2013-05-19 15:44:43.000000000 +0200
@@ -7,7 +7,7 @@
  * This is alpha software. Use entirely on your own risk.             * 
  **********************************************************************
  
- (C) Thomas Hergenhahn (thomas.hergenhahn@web.de) 2002, 2003.
+ (C) Thomas Hergenhahn (thomas.hergenhahn@web.de) 2002...2013.
 
  This is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
Binärdateien ../libnodave-0.8.4.6/pascal/testMPI and ../libnodave-0.8.5/pascal/testMPI sind verschieden.
Nur in ../libnodave-0.8.4.6/pascal: testmpi.exe.
Binärdateien ../libnodave-0.8.4.6/pascal/testMPI.o and ../libnodave-0.8.5/pascal/testMPI.o sind verschieden.
Nur in ../libnodave-0.8.4.6/pascal: testmpi.ow.
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/pascal/testMPI.pas ../libnodave-0.8.5/pascal/testMPI.pas
--- ../libnodave-0.8.4.6/pascal/testMPI.pas	2007-01-09 00:23:26.000000000 +0100
+++ ../libnodave-0.8.5/pascal/testMPI.pas	2013-05-19 15:44:53.000000000 +0200
@@ -7,7 +7,7 @@
  * This is alpha software. Use entirely on your own risk.             * 
  **********************************************************************
  
- (C) Thomas Hergenhahn (thomas.hergenhahn@web.de) 2002, 2003.
+ (C) Thomas Hergenhahn (thomas.hergenhahn@web.de) 2002...2013.
 
  This is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
Binärdateien ../libnodave-0.8.4.6/pascal/testPPI and ../libnodave-0.8.5/pascal/testPPI sind verschieden.
Nur in ../libnodave-0.8.4.6/pascal: testppi.exe.
Binärdateien ../libnodave-0.8.4.6/pascal/testPPI_IBH and ../libnodave-0.8.5/pascal/testPPI_IBH sind verschieden.
Nur in ../libnodave-0.8.4.6/pascal: testppi_ibh.exe.
Binärdateien ../libnodave-0.8.4.6/pascal/testPPI_IBH.o and ../libnodave-0.8.5/pascal/testPPI_IBH.o sind verschieden.
Nur in ../libnodave-0.8.4.6/pascal: testppi_ibh.ow.
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/pascal/testPPI_IBH.pas ../libnodave-0.8.5/pascal/testPPI_IBH.pas
--- ../libnodave-0.8.4.6/pascal/testPPI_IBH.pas	2007-01-09 00:23:26.000000000 +0100
+++ ../libnodave-0.8.5/pascal/testPPI_IBH.pas	2013-05-19 15:45:03.000000000 +0200
@@ -7,7 +7,7 @@
  * This is alpha software. Use entirely on your own risk.             * 
  **********************************************************************
  
- (C) Thomas Hergenhahn (thomas.hergenhahn@web.de) 2002, 2003.
+ (C) Thomas Hergenhahn (thomas.hergenhahn@web.de) 2002...2013.
 
  This is free software; you can redistribute it and/or modify
  it under the terms of the GNU Library General Public License as published by
Binärdateien ../libnodave-0.8.4.6/pascal/testPPI.o and ../libnodave-0.8.5/pascal/testPPI.o sind verschieden.
Nur in ../libnodave-0.8.4.6/pascal: testppi.ow.
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/pascal/testPPI.pas ../libnodave-0.8.5/pascal/testPPI.pas
--- ../libnodave-0.8.4.6/pascal/testPPI.pas	2007-01-09 00:23:26.000000000 +0100
+++ ../libnodave-0.8.5/pascal/testPPI.pas	2013-05-19 15:45:14.000000000 +0200
@@ -7,7 +7,7 @@
  * This is alpha software. Use entirely on your own risk.             * 
  **********************************************************************
  
- (C) Thomas Hergenhahn (thomas.hergenhahn@web.de) 2002, 2003.
+ (C) Thomas Hergenhahn (thomas.hergenhahn@web.de) 2002...2013.
 
  This is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
Binärdateien ../libnodave-0.8.4.6/pascal/tests.o and ../libnodave-0.8.5/pascal/tests.o sind verschieden.
Nur in ../libnodave-0.8.4.6/pascal: tests.ow.
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/pascal/tests.pas ../libnodave-0.8.5/pascal/tests.pas
--- ../libnodave-0.8.4.6/pascal/tests.pas	2007-01-09 00:23:26.000000000 +0100
+++ ../libnodave-0.8.5/pascal/tests.pas	2013-05-19 15:42:39.000000000 +0200
@@ -6,7 +6,7 @@
 , windows
 {$endif}
 {$ifdef LINUX}
-,oldlinux
+ ,oldlinux
 {$define UNIX_STYLE}
 {$endif}
 ;
@@ -18,6 +18,7 @@
 
 implementation
 
+
 procedure wait;
 begin
     writeln('Press return to continue.');
Binärdateien ../libnodave-0.8.4.6/pascal/tests.ppu and ../libnodave-0.8.5/pascal/tests.ppu sind verschieden.
Nur in ../libnodave-0.8.4.6/pascal: tests.ppw.
Binärdateien ../libnodave-0.8.4.6/PERL/blib/arch/auto/Nodave/Nodave.so and ../libnodave-0.8.5/PERL/blib/arch/auto/Nodave/Nodave.so sind verschieden.
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/PERL/blib/man3/Nodave.3pm ../libnodave-0.8.5/PERL/blib/man3/Nodave.3pm
--- ../libnodave-0.8.4.6/PERL/blib/man3/Nodave.3pm	2011-02-28 02:16:11.000000000 +0100
+++ ../libnodave-0.8.5/PERL/blib/man3/Nodave.3pm	2013-08-14 23:19:46.000000000 +0200
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
+.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -124,7 +124,7 @@
 .\" ========================================================================
 .\"
 .IX Title "Nodave 3pm"
-.TH Nodave 3pm "2005-08-15" "perl v5.10.1" "User Contributed Perl Documentation"
+.TH Nodave 3pm "2005-08-15" "perl v5.14.2" "User Contributed Perl Documentation"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/PERL/Makefile ../libnodave-0.8.5/PERL/Makefile
--- ../libnodave-0.8.4.6/PERL/Makefile	2011-02-28 02:16:02.000000000 +0100
+++ ../libnodave-0.8.5/PERL/Makefile	2013-08-14 23:19:31.000000000 +0200
@@ -1,7 +1,7 @@
 # This Makefile is for the Nodave extension to perl.
 #
 # It was generated automatically by MakeMaker version
-# 6.55_02 (Revision: 65502) from the contents of
+# 6.57_05 (Revision: 65705) from the contents of
 # Makefile.PL. Don't edit this file, edit Makefile.PL instead.
 #
 #       ANY CHANGES MADE HERE WILL BE LOST!
@@ -12,7 +12,7 @@
 #   MakeMaker Parameters:
 
 #     ABSTRACT_FROM => q[lib/Nodave.pm]
-#     AUTHOR => q[Thomas Hergenhahn <thomas.hergenhahn@web,de>]
+#     AUTHOR => [q[Thomas Hergenhahn <thomas.hergenhahn@web,de>]]
 #     BUILD_REQUIRES => {  }
 #     DEFINE => q[]
 #     INC => q[-I.]
@@ -26,7 +26,7 @@
 
 # --- MakeMaker const_config section:
 
-# These definitions are from config.sh (via /usr/lib/perl/5.10/Config.pm).
+# These definitions are from config.sh (via /usr/lib/perl/5.14/Config.pm).
 # They may have been overridden via Makefile.PL or on the command line.
 AR = ar
 CC = cc
@@ -39,14 +39,14 @@
 LD = cc
 LDDLFLAGS = -shared -O2 -g -L/usr/local/lib -fstack-protector
 LDFLAGS =  -fstack-protector -L/usr/local/lib
-LIBC = /lib/libc-2.11.1.so
+LIBC = 
 LIB_EXT = .a
 OBJ_EXT = .o
 OSNAME = linux
-OSVERS = 2.6.24-27-server
+OSVERS = 2.6.42-37-generic
 RANLIB = :
-SITELIBEXP = /usr/local/share/perl/5.10.1
-SITEARCHEXP = /usr/local/lib/perl/5.10.1
+SITELIBEXP = /usr/local/share/perl/5.14.2
+SITEARCHEXP = /usr/local/lib/perl/5.14.2
 SO = so
 VENDORARCHEXP = /usr/lib/perl5
 VENDORLIBEXP = /usr/share/perl5
@@ -79,15 +79,15 @@
 PERLPREFIX = $(PREFIX)
 SITEPREFIX = $(PREFIX)/local
 VENDORPREFIX = $(PREFIX)
-INSTALLPRIVLIB = $(PERLPREFIX)/share/perl/5.10
+INSTALLPRIVLIB = $(PERLPREFIX)/share/perl/5.14
 DESTINSTALLPRIVLIB = $(DESTDIR)$(INSTALLPRIVLIB)
-INSTALLSITELIB = $(SITEPREFIX)/share/perl/5.10.1
+INSTALLSITELIB = $(SITEPREFIX)/share/perl/5.14.2
 DESTINSTALLSITELIB = $(DESTDIR)$(INSTALLSITELIB)
 INSTALLVENDORLIB = $(VENDORPREFIX)/share/perl5
 DESTINSTALLVENDORLIB = $(DESTDIR)$(INSTALLVENDORLIB)
-INSTALLARCHLIB = $(PERLPREFIX)/lib/perl/5.10
+INSTALLARCHLIB = $(PERLPREFIX)/lib/perl/5.14
 DESTINSTALLARCHLIB = $(DESTDIR)$(INSTALLARCHLIB)
-INSTALLSITEARCH = $(SITEPREFIX)/lib/perl/5.10.1
+INSTALLSITEARCH = $(SITEPREFIX)/lib/perl/5.14.2
 DESTINSTALLSITEARCH = $(DESTDIR)$(INSTALLSITEARCH)
 INSTALLVENDORARCH = $(VENDORPREFIX)/lib/perl5
 DESTINSTALLVENDORARCH = $(DESTDIR)$(INSTALLVENDORARCH)
@@ -115,14 +115,14 @@
 DESTINSTALLSITEMAN3DIR = $(DESTDIR)$(INSTALLSITEMAN3DIR)
 INSTALLVENDORMAN3DIR = $(VENDORPREFIX)/share/man/man3
 DESTINSTALLVENDORMAN3DIR = $(DESTDIR)$(INSTALLVENDORMAN3DIR)
-PERL_LIB = /usr/share/perl/5.10
-PERL_ARCHLIB = /usr/lib/perl/5.10
+PERL_LIB = /usr/share/perl/5.14
+PERL_ARCHLIB = /usr/lib/perl/5.14
 LIBPERL_A = libperl.a
 FIRST_MAKEFILE = Makefile
 MAKEFILE_OLD = Makefile.old
 MAKE_APERL_FILE = Makefile.aperl
 PERLMAINCC = $(CC)
-PERL_INC = /usr/lib/perl/5.10/CORE
+PERL_INC = /usr/lib/perl/5.14/CORE
 PERL = /usr/bin/perl
 FULLPERL = /usr/bin/perl
 ABSPERL = $(PERL)
@@ -137,9 +137,9 @@
 PERM_RW = 644
 PERM_RWX = 755
 
-MAKEMAKER   = /usr/share/perl/5.10/ExtUtils/MakeMaker.pm
-MM_VERSION  = 6.55_02
-MM_REVISION = 65502
+MAKEMAKER   = /usr/share/perl/5.14/ExtUtils/MakeMaker.pm
+MM_VERSION  = 6.57_05
+MM_REVISION = 65705
 
 # FULLEXT = Pathname for extension directory (eg Foo/Bar/Oracle).
 # BASEEXT = Basename part of FULLEXT. May be just equal FULLEXT. (eg Oracle)
@@ -199,7 +199,7 @@
 
 
 # --- MakeMaker platform_constants section:
-MM_Unix_VERSION = 6.55_02
+MM_Unix_VERSION = 6.57_05
 PERL_MALLOC_DEF = -DPERL_EXTMALLOC_DEF -Dmalloc=Perl_malloc -Dfree=Perl_mfree -Drealloc=Perl_realloc -Dcalloc=Perl_calloc
 
 
@@ -211,12 +211,12 @@
 
 # --- MakeMaker tool_xsubpp section:
 
-XSUBPPDIR = /usr/share/perl/5.10/ExtUtils
+XSUBPPDIR = /usr/share/perl/5.14/ExtUtils
 XSUBPP = $(XSUBPPDIR)$(DFSEP)xsubpp
 XSUBPPRUN = $(PERLRUN) $(XSUBPP)
 XSPROTOARG = 
-XSUBPPDEPS = /usr/share/perl/5.10/ExtUtils/typemap typemap $(XSUBPP)
-XSUBPPARGS = -typemap /usr/share/perl/5.10/ExtUtils/typemap -typemap typemap
+XSUBPPDEPS = /usr/share/perl/5.14/ExtUtils/typemap typemap $(XSUBPP)
+XSUBPPARGS = -typemap /usr/share/perl/5.14/ExtUtils/typemap -typemap typemap
 XSUBPP_EXTRA_ARGS = 
 
 
@@ -297,7 +297,6 @@
 EXTRALIBS = -lnodave
 LDLOADLIBS = -lnodave
 BSLOADLIBS = 
-LD_RUN_PATH = /usr/local/lib
 
 
 # --- MakeMaker const_cccmd section:
@@ -482,7 +481,7 @@
 
 $(INST_DYNAMIC): $(OBJECT) $(MYEXTLIB) $(BOOTSTRAP) $(INST_ARCHAUTODIR)$(DFSEP).exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(PERL_ARCHIVE_AFTER) $(INST_DYNAMIC_DEP)
 	$(RM_F) $@
-	LD_RUN_PATH="$(LD_RUN_PATH)" $(LD)  $(LDDLFLAGS) $(LDFROM) $(OTHERLDFLAGS) -o $@ $(MYEXTLIB)	\
+	$(LD)  $(LDDLFLAGS) $(LDFROM) $(OTHERLDFLAGS) -o $@ $(MYEXTLIB)	\
 	  $(PERL_ARCHIVE) $(LDLOADLIBS) $(PERL_ARCHIVE_AFTER) $(EXPORT_LIST)	\
 	  $(INST_DYNAMIC_FIX)
 	$(CHMOD) $(PERM_RWX) $@
@@ -545,17 +544,18 @@
 	  Nodave.c core.[0-9] \
 	  $(INST_ARCHAUTODIR)/extralibs.all core.[0-9][0-9] \
 	  $(BASEEXT).bso pm_to_blib.ts \
-	  core.[0-9][0-9][0-9][0-9] $(BASEEXT).x \
-	  $(BOOTSTRAP) perl$(EXE_EXT) \
-	  tmon.out *$(OBJ_EXT) \
-	  pm_to_blib $(INST_ARCHAUTODIR)/extralibs.ld \
-	  blibdirs.ts core.[0-9][0-9][0-9][0-9][0-9] \
-	  *perl.core core.*perl.*.? \
-	  $(MAKE_APERL_FILE) perl \
-	  $(BASEEXT).def core.[0-9][0-9][0-9] \
-	  mon.out lib$(BASEEXT).def \
-	  perlmain.c perl.exe \
-	  so_locations $(BASEEXT).exp 
+	  core.[0-9][0-9][0-9][0-9] MYMETA.yml \
+	  $(BASEEXT).x $(BOOTSTRAP) \
+	  perl$(EXE_EXT) tmon.out \
+	  *$(OBJ_EXT) pm_to_blib \
+	  $(INST_ARCHAUTODIR)/extralibs.ld blibdirs.ts \
+	  core.[0-9][0-9][0-9][0-9][0-9] *perl.core \
+	  core.*perl.*.? $(MAKE_APERL_FILE) \
+	  $(BASEEXT).def perl \
+	  core.[0-9][0-9][0-9] mon.out \
+	  lib$(BASEEXT).def perlmain.c \
+	  perl.exe so_locations \
+	  $(BASEEXT).exp 
 	- $(RM_RF) \
 	  blib 
 	- $(MV) $(FIRST_MAKEFILE) $(MAKEFILE_OLD) $(DEV_NULL)
@@ -596,7 +596,7 @@
 	$(NOECHO) $(ECHO) '    directory:' >> META_new.yml
 	$(NOECHO) $(ECHO) '        - t' >> META_new.yml
 	$(NOECHO) $(ECHO) '        - inc' >> META_new.yml
-	$(NOECHO) $(ECHO) 'generated_by:       ExtUtils::MakeMaker version 6.55_02' >> META_new.yml
+	$(NOECHO) $(ECHO) 'generated_by:       ExtUtils::MakeMaker version 6.57_05' >> META_new.yml
 	$(NOECHO) $(ECHO) 'meta-spec:' >> META_new.yml
 	$(NOECHO) $(ECHO) '    url:      http://module-build.sourceforge.net/META-spec-v1.4.html' >> META_new.yml
 	$(NOECHO) $(ECHO) '    version:  1.4' >> META_new.yml
@@ -807,7 +807,6 @@
 	$(PERL_INC)/INTERN.h		\
 	$(PERL_INC)/XSUB.h		\
 	$(PERL_INC)/av.h		\
-	$(PERL_INC)/cc_runtime.h	\
 	$(PERL_INC)/config.h		\
 	$(PERL_INC)/cop.h		\
 	$(PERL_INC)/cv.h		\
@@ -925,7 +924,7 @@
 	$(NOECHO) $(ECHO) '    <ABSTRACT>Perl extension for Communication with Siemens PLCs.</ABSTRACT>' >> $(DISTNAME).ppd
 	$(NOECHO) $(ECHO) '    <AUTHOR>Thomas Hergenhahn &lt;thomas.hergenhahn@web,de&gt;</AUTHOR>' >> $(DISTNAME).ppd
 	$(NOECHO) $(ECHO) '    <IMPLEMENTATION>' >> $(DISTNAME).ppd
-	$(NOECHO) $(ECHO) '        <ARCHITECTURE NAME="i486-linux-gnu-thread-multi-5.10" />' >> $(DISTNAME).ppd
+	$(NOECHO) $(ECHO) '        <ARCHITECTURE NAME="i686-linux-gnu-thread-multi-64int-5.14" />' >> $(DISTNAME).ppd
 	$(NOECHO) $(ECHO) '        <CODEBASE HREF="" />' >> $(DISTNAME).ppd
 	$(NOECHO) $(ECHO) '    </IMPLEMENTATION>' >> $(DISTNAME).ppd
 	$(NOECHO) $(ECHO) '</SOFTPKG>' >> $(DISTNAME).ppd
Nur in ../libnodave-0.8.5/PERL: MYMETA.yml.
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/PERL/Nodave.c ../libnodave-0.8.5/PERL/Nodave.c
--- ../libnodave-0.8.4.6/PERL/Nodave.c	2011-02-28 02:16:03.000000000 +0100
+++ ../libnodave-0.8.5/PERL/Nodave.c	2013-05-17 21:53:59.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * This file was generated automatically by ExtUtils::ParseXS version 2.2002 from the
+ * This file was generated automatically by ExtUtils::ParseXS version 2.2210 from the
  * contents of Nodave.xs. Do not edit this file, edit Nodave.xs instead.
  *
  *	ANY CHANGES MADE HERE WILL BE LOST! 
@@ -97,7 +97,16 @@
 
 #endif
 
-#line 101 "Nodave.c"
+/* NOTE: the prototype of newXSproto() is different in versions of perls,
+ * so we define a portable version of newXSproto()
+ */
+#ifdef newXS_flags
+#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
+#else
+#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
+#endif /* !defined(newXS_flags) */
+
+#line 110 "Nodave.c"
 
 /* INCLUDE:  Including 'const-xs.inc' from 'Nodave.xs' */
 
@@ -115,7 +124,7 @@
     PERL_UNUSED_VAR(ax); /* -Wall */
     SP -= items;
     {
-#line 4 "const-xs.inc"
+#line 4 "./const-xs.inc"
 #ifdef dXSTARG
 	dXSTARG; /* Faster if we have it.  */
 #else
@@ -126,10 +135,10 @@
 	IV		iv;
 	/* NV		nv;	Uncomment this if you need to return NVs */
 	/* const char	*pv;	Uncomment this if you need to return PVs */
-#line 130 "Nodave.c"
+#line 139 "Nodave.c"
 	SV *	sv = ST(0);
 	const char *	s = SvPV(sv, len);
-#line 18 "const-xs.inc"
+#line 18 "./const-xs.inc"
         /* Change this to constant(aTHX_ s, len, &iv, &nv);
            if you need to return both NVs and IVs */
 	type = constant(aTHX_ s, len, &iv);
@@ -203,7 +212,7 @@
                type, s));
           PUSHs(sv);
         }
-#line 207 "Nodave.c"
+#line 216 "Nodave.c"
 	PUTBACK;
 	return;
     }
@@ -229,7 +238,7 @@
 	dXSTARG;
 #line 57 "Nodave.xs"
     RETVAL=daveStrerror(code);
-#line 233 "Nodave.c"
+#line 242 "Nodave.c"
 	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
     }
     XSRETURN(1);
@@ -250,7 +259,7 @@
 	int	level = (int)SvIV(ST(0));
 #line 66 "Nodave.xs"
 	daveSetDebug(level);
-#line 254 "Nodave.c"
+#line 263 "Nodave.c"
     }
     XSRETURN_EMPTY;
 }
@@ -271,7 +280,7 @@
 	dXSTARG;
 #line 73 "Nodave.xs"
 	RETVAL = daveGetDebug();
-#line 275 "Nodave.c"
+#line 284 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -301,7 +310,7 @@
 	sif.rfd=r;
 	sif.wfd=w;
 	RETVAL = daveNewInterface(sif,name,y,x,z);
-#line 305 "Nodave.c"
+#line 314 "Nodave.c"
 	ST(0) = sv_newmortal();
 	sv_setref_pv(ST(0), "DaveInterface", (void*)RETVAL);
     }
@@ -326,7 +335,7 @@
 	int	z = (int)SvIV(ST(3));
 	DaveConnection	RETVAL;
 
-	if (sv_derived_from(ST(0), "DaveInterface")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveInterface")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    di = INT2PTR(DaveInterface,tmp);
 	}
@@ -336,7 +345,7 @@
 			"di", "DaveInterface");
 #line 105 "Nodave.xs"
 	RETVAL = daveNewConnection(di,y,x,z);
-#line 340 "Nodave.c"
+#line 349 "Nodave.c"
 	ST(0) = sv_newmortal();
 	sv_setref_pv(ST(0), "DaveConnection", (void*)RETVAL);
     }
@@ -359,7 +368,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -369,7 +378,7 @@
 			"dc", "DaveConnection");
 #line 114 "Nodave.xs"
 	RETVAL = daveGetResponse(dc);	
-#line 373 "Nodave.c"
+#line 382 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -392,7 +401,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -401,7 +410,7 @@
 			"Nodave::daveSendMessage",
 			"dc", "DaveConnection");
 
-	if (sv_derived_from(ST(1), "DavePDU")) {
+	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DavePDU")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(1)));
 	    p = INT2PTR(DavePDU,tmp);
 	}
@@ -411,7 +420,7 @@
 			"p", "DavePDU");
 #line 123 "Nodave.xs"
 	RETVAL = daveSendMessage(dc, p);
-#line 415 "Nodave.c"
+#line 424 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -431,7 +440,7 @@
     {
 	DavePDU	p;
 
-	if (sv_derived_from(ST(0), "DavePDU")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DavePDU")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    p = INT2PTR(DavePDU,tmp);
 	}
@@ -441,7 +450,7 @@
 			"p", "DavePDU");
 #line 131 "Nodave.xs"
     _daveDumpPDU(p);
-#line 445 "Nodave.c"
+#line 454 "Nodave.c"
     }
     XSRETURN_EMPTY;
 }
@@ -463,7 +472,7 @@
 	int	len = (int)SvIV(ST(2));
 #line 139 "Nodave.xs"
     _daveDump(name,b,len);
-#line 467 "Nodave.c"
+#line 476 "Nodave.c"
     }
     XSRETURN_EMPTY;
 }
@@ -485,7 +494,7 @@
 	dXSTARG;
 #line 145 "Nodave.xs"
 	RETVAL = daveBlockName(bn);
-#line 489 "Nodave.c"
+#line 498 "Nodave.c"
 	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
     }
     XSRETURN(1);
@@ -508,7 +517,7 @@
 	dXSTARG;
 #line 153 "Nodave.xs"
 	RETVAL = daveAreaName(n);
-#line 512 "Nodave.c"
+#line 521 "Nodave.c"
 	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
     }
     XSRETURN(1);
@@ -531,7 +540,7 @@
 	dXSTARG;
 #line 161 "Nodave.xs"
 	RETVAL = daveSwapIed_16(ff);
-#line 535 "Nodave.c"
+#line 544 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -554,7 +563,7 @@
 	dXSTARG;
 #line 169 "Nodave.xs"
 	RETVAL = daveSwapIed_32(ff);
-#line 558 "Nodave.c"
+#line 567 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -577,7 +586,7 @@
 	float	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -587,7 +596,7 @@
 			"dc", "DaveConnection");
 #line 179 "Nodave.xs"
 	RETVAL = daveGetFloatAt(dc,pos);
-#line 591 "Nodave.c"
+#line 600 "Nodave.c"
 	XSprePUSH; PUSHn((double)RETVAL);
     }
     XSRETURN(1);
@@ -610,7 +619,7 @@
 	dXSTARG;
 #line 187 "Nodave.xs"
 	RETVAL = toPLCfloat(f);
-#line 614 "Nodave.c"
+#line 623 "Nodave.c"
 	XSprePUSH; PUSHn((double)RETVAL);
     }
     XSRETURN(1);
@@ -633,7 +642,7 @@
 	dXSTARG;
 #line 195 "Nodave.xs"
 	RETVAL = daveToPLCfloat(f);
-#line 637 "Nodave.c"
+#line 646 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -657,7 +666,7 @@
 	dXSTARG;
 #line 205 "Nodave.xs"
 	RETVAL = daveGetS8from(buffer+pos);
-#line 661 "Nodave.c"
+#line 670 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -681,7 +690,7 @@
 	dXSTARG;
 #line 215 "Nodave.xs"
 	RETVAL = daveGetU8from(buffer+pos);
-#line 685 "Nodave.c"
+#line 694 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -705,7 +714,7 @@
 	dXSTARG;
 #line 225 "Nodave.xs"
 	RETVAL = daveGetS16from(buffer+pos);
-#line 709 "Nodave.c"
+#line 718 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -729,7 +738,7 @@
 	dXSTARG;
 #line 235 "Nodave.xs"
 	RETVAL = daveGetU16from(buffer+pos);
-#line 733 "Nodave.c"
+#line 742 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -753,7 +762,7 @@
 	dXSTARG;
 #line 245 "Nodave.xs"
 	RETVAL = daveGetS32from(buffer+pos);
-#line 757 "Nodave.c"
+#line 766 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -777,7 +786,7 @@
 	dXSTARG;
 #line 255 "Nodave.xs"
 	RETVAL = daveGetU32from(buffer+pos);
-#line 781 "Nodave.c"
+#line 790 "Nodave.c"
 	XSprePUSH; PUSHu((UV)RETVAL);
     }
     XSRETURN(1);
@@ -801,7 +810,7 @@
 	dXSTARG;
 #line 265 "Nodave.xs"
 	RETVAL = daveGetFloatfrom(buffer+pos);
-#line 805 "Nodave.c"
+#line 814 "Nodave.c"
 	XSprePUSH; PUSHn((double)RETVAL);
     }
     XSRETURN(1);
@@ -823,7 +832,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -833,7 +842,7 @@
 			"dc", "DaveConnection");
 #line 274 "Nodave.xs"
 	RETVAL = daveGetS8(dc);
-#line 837 "Nodave.c"
+#line 846 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -855,7 +864,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -865,7 +874,7 @@
 			"dc", "DaveConnection");
 #line 283 "Nodave.xs"
 	RETVAL = daveGetU8(dc);
-#line 869 "Nodave.c"
+#line 878 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -887,7 +896,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -897,7 +906,7 @@
 			"dc", "DaveConnection");
 #line 293 "Nodave.xs"
 	RETVAL = daveGetS16(dc);
-#line 901 "Nodave.c"
+#line 910 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -919,7 +928,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -929,7 +938,7 @@
 			"dc", "DaveConnection");
 #line 303 "Nodave.xs"
 	RETVAL = daveGetU16(dc);
-#line 933 "Nodave.c"
+#line 942 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -951,7 +960,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -961,7 +970,7 @@
 			"dc", "DaveConnection");
 #line 313 "Nodave.xs"
 	RETVAL = daveGetS32(dc);
-#line 965 "Nodave.c"
+#line 974 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -983,7 +992,7 @@
 	unsigned int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -993,7 +1002,7 @@
 			"dc", "DaveConnection");
 #line 323 "Nodave.xs"
 	RETVAL = daveGetU32(dc);
-#line 997 "Nodave.c"
+#line 1006 "Nodave.c"
 	XSprePUSH; PUSHu((UV)RETVAL);
     }
     XSRETURN(1);
@@ -1015,7 +1024,7 @@
 	float	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1025,7 +1034,7 @@
 			"dc", "DaveConnection");
 #line 333 "Nodave.xs"
 	RETVAL = daveGetFloat(dc);
-#line 1029 "Nodave.c"
+#line 1038 "Nodave.c"
 	XSprePUSH; PUSHn((double)RETVAL);
     }
     XSRETURN(1);
@@ -1048,7 +1057,7 @@
 	float	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1058,7 +1067,7 @@
 			"dc", "DaveConnection");
 #line 343 "Nodave.xs"
 	RETVAL = daveGetS8At(dc,pos);
-#line 1062 "Nodave.c"
+#line 1071 "Nodave.c"
 	XSprePUSH; PUSHn((double)RETVAL);
     }
     XSRETURN(1);
@@ -1081,7 +1090,7 @@
 	float	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1091,7 +1100,7 @@
 			"dc", "DaveConnection");
 #line 353 "Nodave.xs"
 	RETVAL = daveGetU8At(dc,pos);
-#line 1095 "Nodave.c"
+#line 1104 "Nodave.c"
 	XSprePUSH; PUSHn((double)RETVAL);
     }
     XSRETURN(1);
@@ -1114,7 +1123,7 @@
 	float	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1124,7 +1133,7 @@
 			"dc", "DaveConnection");
 #line 363 "Nodave.xs"
 	RETVAL = daveGetS16At(dc,pos);
-#line 1128 "Nodave.c"
+#line 1137 "Nodave.c"
 	XSprePUSH; PUSHn((double)RETVAL);
     }
     XSRETURN(1);
@@ -1147,7 +1156,7 @@
 	float	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1157,7 +1166,7 @@
 			"dc", "DaveConnection");
 #line 373 "Nodave.xs"
 	RETVAL = daveGetU16At(dc,pos);
-#line 1161 "Nodave.c"
+#line 1170 "Nodave.c"
 	XSprePUSH; PUSHn((double)RETVAL);
     }
     XSRETURN(1);
@@ -1180,7 +1189,7 @@
 	float	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1190,7 +1199,7 @@
 			"dc", "DaveConnection");
 #line 383 "Nodave.xs"
 	RETVAL = daveGetS32At(dc,pos);
-#line 1194 "Nodave.c"
+#line 1203 "Nodave.c"
 	XSprePUSH; PUSHn((double)RETVAL);
     }
     XSRETURN(1);
@@ -1213,7 +1222,7 @@
 	float	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1223,7 +1232,7 @@
 			"dc", "DaveConnection");
 #line 393 "Nodave.xs"
 	RETVAL = daveGetU32At(dc,pos);
-#line 1227 "Nodave.c"
+#line 1236 "Nodave.c"
 	XSprePUSH; PUSHn((double)RETVAL);
     }
     XSRETURN(1);
@@ -1245,7 +1254,7 @@
 	float	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1255,7 +1264,7 @@
 			"dc", "DaveConnection");
 #line 402 "Nodave.xs"
 	RETVAL = daveGetSeconds(dc);
-#line 1259 "Nodave.c"
+#line 1268 "Nodave.c"
 	XSprePUSH; PUSHn((double)RETVAL);
     }
     XSRETURN(1);
@@ -1278,7 +1287,7 @@
 	float	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1288,7 +1297,7 @@
 			"dc", "DaveConnection");
 #line 412 "Nodave.xs"
 	RETVAL = daveGetSecondsAt(dc,pos);
-#line 1292 "Nodave.c"
+#line 1301 "Nodave.c"
 	XSprePUSH; PUSHn((double)RETVAL);
     }
     XSRETURN(1);
@@ -1310,7 +1319,7 @@
 	float	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1320,7 +1329,7 @@
 			"dc", "DaveConnection");
 #line 421 "Nodave.xs"
 	RETVAL = daveGetCounterValue(dc);
-#line 1324 "Nodave.c"
+#line 1333 "Nodave.c"
 	XSprePUSH; PUSHn((double)RETVAL);
     }
     XSRETURN(1);
@@ -1343,7 +1352,7 @@
 	float	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1353,7 +1362,7 @@
 			"dc", "DaveConnection");
 #line 431 "Nodave.xs"
 	RETVAL = daveGetCounterValueAt(dc,pos);
-#line 1357 "Nodave.c"
+#line 1366 "Nodave.c"
 	XSprePUSH; PUSHn((double)RETVAL);
     }
     XSRETURN(1);
@@ -1375,7 +1384,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1385,7 +1394,7 @@
 			"dc", "DaveConnection");
 #line 443 "Nodave.xs"
 	RETVAL = daveConnectPLC(dc);
-#line 1389 "Nodave.c"
+#line 1398 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -1411,7 +1420,7 @@
 	int	start = (int)SvIV(ST(3));
 	int	bytes = (int)SvIV(ST(4));
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1426,7 +1435,7 @@
 	EXTEND(SP,2);
 	PUSHs(sv_2mortal(newSVpvn(&buffer[0],bytes)));
 	PUSHs(sv_2mortal(newSViv(rv)));
-#line 1430 "Nodave.c"
+#line 1439 "Nodave.c"
 	PUTBACK;
 	return;
     }
@@ -1453,7 +1462,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1463,7 +1472,7 @@
 			"dc", "DaveConnection");
 #line 474 "Nodave.xs"
 	RETVAL = daveWriteBytes (dc, area, areaNumber, start, bytes, buffer);
-#line 1467 "Nodave.c"
+#line 1476 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -1489,7 +1498,7 @@
 	int	start = (int)SvIV(ST(3));
 	int	bytes;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1511,7 +1520,7 @@
 	EXTEND(SP,2);
 	PUSHs(sv_2mortal(newSVpvn(&buffer[0],bytes)));
 	PUSHs(sv_2mortal(newSViv(rv)));
-#line 1515 "Nodave.c"
+#line 1524 "Nodave.c"
 	PUTBACK;
 	return;
     }
@@ -1538,7 +1547,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1548,7 +1557,7 @@
 			"dc", "DaveConnection");
 #line 505 "Nodave.xs"
 	RETVAL = daveWriteBits (dc, area, areaNumber, start, bytes, buffer);
-#line 1552 "Nodave.c"
+#line 1561 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -1574,7 +1583,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1584,7 +1593,7 @@
 			"dc", "DaveConnection");
 #line 518 "Nodave.xs"
 	RETVAL = daveSetBit (dc, area, DB, byteAdr, bitAdr);
-#line 1588 "Nodave.c"
+#line 1597 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -1610,7 +1619,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1620,7 +1629,7 @@
 			"dc", "DaveConnection");
 #line 531 "Nodave.xs"
 	RETVAL = daveClrBit (dc, area, DB, byteAdr, bitAdr);
-#line 1624 "Nodave.c"
+#line 1633 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -1641,7 +1650,7 @@
 	DavePDU	RETVAL;
 #line 551 "Nodave.xs"
 	RETVAL = daveNewPDU();
-#line 1645 "Nodave.c"
+#line 1654 "Nodave.c"
 	ST(0) = sv_newmortal();
 	sv_setref_pv(ST(0), "DavePDU", (void*)RETVAL);
     }
@@ -1663,7 +1672,7 @@
 	DaveResultSet	RETVAL;
 #line 560 "Nodave.xs"
 	RETVAL = daveNewResultSet();
-#line 1667 "Nodave.c"
+#line 1676 "Nodave.c"
 	ST(0) = sv_newmortal();
 	sv_setref_pv(ST(0), "DaveResultSet", (void*)RETVAL);
     }
@@ -1686,7 +1695,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveInterface")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveInterface")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    di = INT2PTR(DaveInterface,tmp);
 	}
@@ -1696,7 +1705,7 @@
 			"di", "DaveInterface");
 #line 572 "Nodave.xs"
 	RETVAL = daveInitAdapter(di);
-#line 1700 "Nodave.c"
+#line 1709 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -1718,7 +1727,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1728,7 +1737,7 @@
 			"dc", "DaveConnection");
 #line 583 "Nodave.xs"
 	RETVAL = daveDisconnectPLC(dc);
-#line 1732 "Nodave.c"
+#line 1741 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -1750,7 +1759,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveInterface")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveInterface")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    di = INT2PTR(DaveInterface,tmp);
 	}
@@ -1760,7 +1769,7 @@
 			"di", "DaveInterface");
 #line 592 "Nodave.xs"
 	RETVAL = daveDisconnectAdapter(di);
-#line 1764 "Nodave.c"
+#line 1773 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -1782,7 +1791,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1792,7 +1801,7 @@
 			"dc", "DaveConnection");
 #line 607 "Nodave.xs"
 	RETVAL = daveStop(dc);
-#line 1796 "Nodave.c"
+#line 1805 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -1814,7 +1823,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1824,7 +1833,7 @@
 			"dc", "DaveConnection");
 #line 616 "Nodave.xs"
 	RETVAL = daveStart(dc);
-#line 1828 "Nodave.c"
+#line 1837 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -1845,7 +1854,7 @@
 	DaveConnection	dc;
 	DavePDU	p;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1854,7 +1863,7 @@
 			"Nodave::davePrepareReadRequest",
 			"dc", "DaveConnection");
 
-	if (sv_derived_from(ST(1), "DavePDU")) {
+	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DavePDU")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(1)));
 	    p = INT2PTR(DavePDU,tmp);
 	}
@@ -1864,7 +1873,7 @@
 			"p", "DavePDU");
 #line 627 "Nodave.xs"
     davePrepareReadRequest(dc, p);
-#line 1868 "Nodave.c"
+#line 1877 "Nodave.c"
     }
     XSRETURN_EMPTY;
 }
@@ -1887,7 +1896,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1896,7 +1905,7 @@
 			"Nodave::daveExecReadRequest",
 			"dc", "DaveConnection");
 
-	if (sv_derived_from(ST(1), "DavePDU")) {
+	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DavePDU")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(1)));
 	    p = INT2PTR(DavePDU,tmp);
 	}
@@ -1905,7 +1914,7 @@
 			"Nodave::daveExecReadRequest",
 			"p", "DavePDU");
 
-	if (sv_derived_from(ST(2), "DaveResultSet")) {
+	if (SvROK(ST(2)) && sv_derived_from(ST(2), "DaveResultSet")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(2)));
 	    rl = INT2PTR(DaveResultSet,tmp);
 	}
@@ -1915,7 +1924,7 @@
 			"rl", "DaveResultSet");
 #line 637 "Nodave.xs"
 	RETVAL = daveExecReadRequest(dc, p, rl);
-#line 1919 "Nodave.c"
+#line 1928 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -1939,7 +1948,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -1948,7 +1957,7 @@
 			"Nodave::daveUseResult",
 			"dc", "DaveConnection");
 
-	if (sv_derived_from(ST(1), "DaveResultSet")) {
+	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DaveResultSet")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(1)));
 	    rl = INT2PTR(DaveResultSet,tmp);
 	}
@@ -1958,7 +1967,7 @@
 			"rl", "DaveResultSet");
 #line 647 "Nodave.xs"
 	RETVAL = daveUseResult(dc, rl, n);
-#line 1962 "Nodave.c"
+#line 1971 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -1978,7 +1987,7 @@
     {
 	DaveResultSet	rl;
 
-	if (sv_derived_from(ST(0), "DaveResultSet")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveResultSet")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    rl = INT2PTR(DaveResultSet,tmp);
 	}
@@ -1988,7 +1997,7 @@
 			"rl", "DaveResultSet");
 #line 655 "Nodave.xs"
 	daveFreeResults(rl);
-#line 1992 "Nodave.c"
+#line 2001 "Nodave.c"
     }
     XSRETURN_EMPTY;
 }
@@ -2008,7 +2017,7 @@
 	DaveConnection	dc;
 	DavePDU	p;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -2017,7 +2026,7 @@
 			"Nodave::davePrepareWriteRequest",
 			"dc", "DaveConnection");
 
-	if (sv_derived_from(ST(1), "DavePDU")) {
+	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DavePDU")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(1)));
 	    p = INT2PTR(DavePDU,tmp);
 	}
@@ -2027,7 +2036,7 @@
 			"p", "DavePDU");
 #line 662 "Nodave.xs"
 	davePrepareWriteRequest(dc, p);
-#line 2031 "Nodave.c"
+#line 2040 "Nodave.c"
     }
     XSRETURN_EMPTY;
 }
@@ -2051,7 +2060,7 @@
 	int	bytes = (int)SvIV(ST(4));
 	char*	buffer = (char *)SvPV_nolen(ST(5));
 
-	if (sv_derived_from(ST(0), "DavePDU")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DavePDU")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    p = INT2PTR(DavePDU,tmp);
 	}
@@ -2061,7 +2070,7 @@
 			"p", "DavePDU");
 #line 673 "Nodave.xs"
     daveAddVarToWriteRequest(p, area, DBnum, start, bytes, buffer);
-#line 2065 "Nodave.c"
+#line 2074 "Nodave.c"
     }
     XSRETURN_EMPTY;
 }
@@ -2085,7 +2094,7 @@
 	int	bytes = (int)SvIV(ST(4));
 	char*	buffer = (char *)SvPV_nolen(ST(5));
 
-	if (sv_derived_from(ST(0), "DavePDU")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DavePDU")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    p = INT2PTR(DavePDU,tmp);
 	}
@@ -2095,7 +2104,7 @@
 			"p", "DavePDU");
 #line 684 "Nodave.xs"
     daveAddBitVarToWriteRequest(p, area, DBnum, start, bytes, buffer);
-#line 2099 "Nodave.c"
+#line 2108 "Nodave.c"
     }
     XSRETURN_EMPTY;
 }
@@ -2118,7 +2127,7 @@
 	int	start = (int)SvIV(ST(3));
 	int	bytes = (int)SvIV(ST(4));
 
-	if (sv_derived_from(ST(0), "DavePDU")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DavePDU")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    p = INT2PTR(DavePDU,tmp);
 	}
@@ -2128,7 +2137,7 @@
 			"p", "DavePDU");
 #line 694 "Nodave.xs"
     daveAddVarToReadRequest(p, area, DBnum, start, bytes);
-#line 2132 "Nodave.c"
+#line 2141 "Nodave.c"
     }
     XSRETURN_EMPTY;
 }
@@ -2151,7 +2160,7 @@
 	int	start = (int)SvIV(ST(3));
 	int	bytes = (int)SvIV(ST(4));
 
-	if (sv_derived_from(ST(0), "DavePDU")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DavePDU")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    p = INT2PTR(DavePDU,tmp);
 	}
@@ -2161,7 +2170,7 @@
 			"p", "DavePDU");
 #line 704 "Nodave.xs"
     daveAddBitVarToReadRequest(p, area, DBnum, start, bytes);
-#line 2165 "Nodave.c"
+#line 2174 "Nodave.c"
     }
     XSRETURN_EMPTY;
 }
@@ -2185,7 +2194,7 @@
 	dXSTARG;
 #line 713 "Nodave.xs"
 	RETVAL = setPort(port, baud, parity);
-#line 2189 "Nodave.c"
+#line 2198 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -2209,7 +2218,7 @@
 	dXSTARG;
 #line 723 "Nodave.xs"
 	RETVAL = openSocket(port, peer);
-#line 2213 "Nodave.c"
+#line 2222 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -2232,7 +2241,7 @@
 	dXSTARG;
 #line 732 "Nodave.xs"
 	RETVAL = closePort(port);
-#line 2236 "Nodave.c"
+#line 2245 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -2255,7 +2264,7 @@
 	dXSTARG;
 #line 741 "Nodave.xs"
 	RETVAL = closeSocket(port);
-#line 2259 "Nodave.c"
+#line 2268 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -2277,7 +2286,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveInterface")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveInterface")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    di = INT2PTR(DaveInterface,tmp);
 	}
@@ -2287,7 +2296,7 @@
 			"di", "DaveInterface");
 #line 750 "Nodave.xs"
 	RETVAL = daveGetTimeout(di);
-#line 2291 "Nodave.c"
+#line 2300 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -2308,7 +2317,7 @@
 	DaveInterface	di;
 	int	time = (int)SvIV(ST(1));
 
-	if (sv_derived_from(ST(0), "DaveInterface")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveInterface")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    di = INT2PTR(DaveInterface,tmp);
 	}
@@ -2318,7 +2327,7 @@
 			"di", "DaveInterface");
 #line 760 "Nodave.xs"
 	daveSetTimeout(di, time);
-#line 2322 "Nodave.c"
+#line 2331 "Nodave.c"
     }
     XSRETURN_EMPTY;
 }
@@ -2339,7 +2348,7 @@
 	char *	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveInterface")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveInterface")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    di = INT2PTR(DaveInterface,tmp);
 	}
@@ -2349,7 +2358,7 @@
 			"di", "DaveInterface");
 #line 767 "Nodave.xs"
 	RETVAL = daveGetName(di);
-#line 2353 "Nodave.c"
+#line 2362 "Nodave.c"
 	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
     }
     XSRETURN(1);
@@ -2371,7 +2380,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -2381,7 +2390,7 @@
 			"dc", "DaveConnection");
 #line 776 "Nodave.xs"
 	RETVAL = daveGetAnswLen(dc);
-#line 2385 "Nodave.c"
+#line 2394 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -2403,7 +2412,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -2413,7 +2422,7 @@
 			"dc", "DaveConnection");
 #line 785 "Nodave.xs"
 	RETVAL = daveGetMaxPDULen(dc);
-#line 2417 "Nodave.c"
+#line 2426 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -2435,7 +2444,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -2445,7 +2454,7 @@
 			"dc", "DaveConnection");
 #line 794 "Nodave.xs"
 	RETVAL = daveGetMPIAdr(dc);
-#line 2449 "Nodave.c"
+#line 2458 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -2468,7 +2477,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveResultSet")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveResultSet")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    drs = INT2PTR(DaveResultSet,tmp);
 	}
@@ -2478,7 +2487,7 @@
 			"drs", "DaveResultSet");
 #line 804 "Nodave.xs"
 	RETVAL = daveGetErrorOfResult (drs, n);
-#line 2482 "Nodave.c"
+#line 2491 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -2503,7 +2512,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveInterface")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveInterface")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    di = INT2PTR(DaveInterface,tmp);
 	}
@@ -2513,7 +2522,7 @@
 			"di", "DaveInterface");
 #line 816 "Nodave.xs"
 	RETVAL = daveForceDisconnectIBH (di,src,dest,mpi);
-#line 2517 "Nodave.c"
+#line 2526 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -2538,7 +2547,7 @@
 	int	RETVAL;
 	dXSTARG;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -2548,7 +2557,7 @@
 			"dc", "DaveConnection");
 #line 828 "Nodave.xs"
 	RETVAL = daveForce200 (dc, area, start, val);
-#line 2552 "Nodave.c"
+#line 2561 "Nodave.c"
 	XSprePUSH; PUSHi((IV)RETVAL);
     }
     XSRETURN(1);
@@ -2570,7 +2579,7 @@
     {
 	DaveConnection	dc;
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -2585,7 +2594,7 @@
 	EXTEND(SP,2);
 	PUSHs(sv_2mortal(newSVpvn(&buffer[0],daveOrderCodeSize)));
 	PUSHs(sv_2mortal(newSViv(rv)));
-#line 2589 "Nodave.c"
+#line 2598 "Nodave.c"
 	PUTBACK;
 	return;
     }
@@ -2609,7 +2618,7 @@
 	int	ID = (int)SvIV(ST(1));
 	int	index = (int)SvIV(ST(2));
 
-	if (sv_derived_from(ST(0), "DaveConnection")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveConnection")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    dc = INT2PTR(DaveConnection,tmp);
 	}
@@ -2624,7 +2633,7 @@
 	EXTEND(SP,2);
 	PUSHs(sv_2mortal(newSVpvn(&buffer[0],daveOrderCodeSize)));
 	PUSHs(sv_2mortal(newSViv(rv)));
-#line 2628 "Nodave.c"
+#line 2637 "Nodave.c"
 	PUTBACK;
 	return;
     }
@@ -2646,7 +2655,7 @@
     {
 	DaveInterface	di;
 
-	if (sv_derived_from(ST(0), "DaveInterface")) {
+	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DaveInterface")) {
 	    IV tmp = SvIV((SV*)SvRV(ST(0)));
 	    di = INT2PTR(DaveInterface,tmp);
 	}
@@ -2661,7 +2670,7 @@
 	EXTEND(SP,2);
 	PUSHs(sv_2mortal(newSVpvn(&buffer[0],daveOrderCodeSize)));
 	PUSHs(sv_2mortal(newSViv(rv)));
-#line 2665 "Nodave.c"
+#line 2674 "Nodave.c"
 	PUTBACK;
 	return;
     }
@@ -2692,7 +2701,7 @@
 #line 873 "Nodave.xs"
 //	printf("freeing DaveInterface %p\n",di);
 	daveFree(di);
-#line 2696 "Nodave.c"
+#line 2705 "Nodave.c"
     }
     XSRETURN_EMPTY;
 }
@@ -2722,7 +2731,7 @@
 #line 881 "Nodave.xs"
 //	printf("freeing DaveConnection %p\n",dc);
 	daveFree(dc);	
-#line 2726 "Nodave.c"
+#line 2735 "Nodave.c"
     }
     XSRETURN_EMPTY;
 }
@@ -2752,7 +2761,7 @@
 #line 889 "Nodave.xs"
 //	printf("freeing DavePDU %p\n",dp);
 	daveFree(dp);	
-#line 2756 "Nodave.c"
+#line 2765 "Nodave.c"
     }
     XSRETURN_EMPTY;
 }
@@ -2783,7 +2792,7 @@
 //	printf("freeing DaveResultSet %p\n",drs);
 	daveFreeResults(drs);
 	daveFree(drs);	
-#line 2787 "Nodave.c"
+#line 2796 "Nodave.c"
     }
     XSRETURN_EMPTY;
 }
@@ -2799,98 +2808,107 @@
 #else
     dXSARGS;
 #endif
+#if (PERL_REVISION == 5 && PERL_VERSION < 9)
+    char* file = __FILE__;
+#else
     const char* file = __FILE__;
+#endif
 
     PERL_UNUSED_VAR(cv); /* -W */
     PERL_UNUSED_VAR(items); /* -W */
+#ifdef XS_APIVERSION_BOOTCHECK
+    XS_APIVERSION_BOOTCHECK;
+#endif
     XS_VERSION_BOOTCHECK ;
 
         newXS("Nodave::constant", XS_Nodave_constant, file);
-        newXSproto("Nodave::daveStrerror", XS_Nodave_daveStrerror, file, "$");
-        newXSproto("Nodave::daveSetDebug", XS_Nodave_daveSetDebug, file, "$");
-        newXSproto("Nodave::daveGetDebug", XS_Nodave_daveGetDebug, file, "");
-        newXSproto("Nodave::daveNewInterface", XS_Nodave_daveNewInterface, file, "$$$$$$");
-        newXSproto("Nodave::daveNewConnection", XS_Nodave_daveNewConnection, file, "$$$$");
-        newXSproto("Nodave::daveGetResponse", XS_Nodave_daveGetResponse, file, "$");
-        newXSproto("Nodave::daveSendMessage", XS_Nodave_daveSendMessage, file, "$");
-        newXSproto("Nodave::daveDumpPDU", XS_Nodave_daveDumpPDU, file, "$");
-        newXSproto("Nodave::daveDump", XS_Nodave_daveDump, file, "$$$");
-        newXSproto("Nodave::daveBlockName", XS_Nodave_daveBlockName, file, "$");
-        newXSproto("Nodave::daveAreaName", XS_Nodave_daveAreaName, file, "$");
-        newXSproto("Nodave::daveSwapIed_16", XS_Nodave_daveSwapIed_16, file, "$");
-        newXSproto("Nodave::daveSwapIed_32", XS_Nodave_daveSwapIed_32, file, "$");
-        newXSproto("Nodave::daveGetFloatAt", XS_Nodave_daveGetFloatAt, file, "$$");
-        newXSproto("Nodave::toPLCfloat", XS_Nodave_toPLCfloat, file, "$");
-        newXSproto("Nodave::daveToPLCfloat", XS_Nodave_daveToPLCfloat, file, "$");
-        newXSproto("Nodave::daveGetS8from", XS_Nodave_daveGetS8from, file, "$$");
-        newXSproto("Nodave::daveGetU8from", XS_Nodave_daveGetU8from, file, "$$");
-        newXSproto("Nodave::daveGetS16from", XS_Nodave_daveGetS16from, file, "$$");
-        newXSproto("Nodave::daveGetU16from", XS_Nodave_daveGetU16from, file, "$$");
-        newXSproto("Nodave::daveGetS32from", XS_Nodave_daveGetS32from, file, "$$");
-        newXSproto("Nodave::daveGetU32from", XS_Nodave_daveGetU32from, file, "$$");
-        newXSproto("Nodave::daveGetFloatfrom", XS_Nodave_daveGetFloatfrom, file, "$$");
-        newXSproto("Nodave::daveGetS8", XS_Nodave_daveGetS8, file, "$");
-        newXSproto("Nodave::daveGetU8", XS_Nodave_daveGetU8, file, "$");
-        newXSproto("Nodave::daveGetS16", XS_Nodave_daveGetS16, file, "$");
-        newXSproto("Nodave::daveGetU16", XS_Nodave_daveGetU16, file, "$");
-        newXSproto("Nodave::daveGetS32", XS_Nodave_daveGetS32, file, "$");
-        newXSproto("Nodave::daveGetU32", XS_Nodave_daveGetU32, file, "$");
-        newXSproto("Nodave::daveGetFloat", XS_Nodave_daveGetFloat, file, "$");
-        newXSproto("Nodave::daveGetS8At", XS_Nodave_daveGetS8At, file, "$$");
-        newXSproto("Nodave::daveGetU8At", XS_Nodave_daveGetU8At, file, "$$");
-        newXSproto("Nodave::daveGetS16At", XS_Nodave_daveGetS16At, file, "$$");
-        newXSproto("Nodave::daveGetU16At", XS_Nodave_daveGetU16At, file, "$$");
-        newXSproto("Nodave::daveGetS32At", XS_Nodave_daveGetS32At, file, "$$");
-        newXSproto("Nodave::daveGetU32At", XS_Nodave_daveGetU32At, file, "$$");
-        newXSproto("Nodave::daveGetSeconds", XS_Nodave_daveGetSeconds, file, "$$");
-        newXSproto("Nodave::daveGetSecondsAt", XS_Nodave_daveGetSecondsAt, file, "$$");
-        newXSproto("Nodave::daveGetCounterValue", XS_Nodave_daveGetCounterValue, file, "$$");
-        newXSproto("Nodave::daveGetCounterValueAt", XS_Nodave_daveGetCounterValueAt, file, "$$");
-        newXSproto("Nodave::daveConnectPLC", XS_Nodave_daveConnectPLC, file, "$");
-        newXSproto("Nodave::daveReadBytes", XS_Nodave_daveReadBytes, file, "$$$$$");
-        newXSproto("Nodave::daveWriteBytes", XS_Nodave_daveWriteBytes, file, "$$$$$$");
-        newXSproto("Nodave::daveReadBits", XS_Nodave_daveReadBits, file, "$$$$;$");
-        newXSproto("Nodave::daveWriteBits", XS_Nodave_daveWriteBits, file, "$$$$$$");
-        newXSproto("Nodave::daveSetBit", XS_Nodave_daveSetBit, file, "$$$$$");
-        newXSproto("Nodave::daveClrBit", XS_Nodave_daveClrBit, file, "$$$$$");
-        newXSproto("Nodave::daveNewPDU", XS_Nodave_daveNewPDU, file, "");
-        newXSproto("Nodave::daveNewResultSet", XS_Nodave_daveNewResultSet, file, "");
-        newXSproto("Nodave::daveInitAdapter", XS_Nodave_daveInitAdapter, file, "$");
-        newXSproto("Nodave::daveDisconnectPLC", XS_Nodave_daveDisconnectPLC, file, "$");
-        newXSproto("Nodave::daveDisconnectAdapter", XS_Nodave_daveDisconnectAdapter, file, "$");
-        newXSproto("Nodave::daveStop", XS_Nodave_daveStop, file, "$");
-        newXSproto("Nodave::daveStart", XS_Nodave_daveStart, file, "$");
-        newXSproto("Nodave::davePrepareReadRequest", XS_Nodave_davePrepareReadRequest, file, "$$");
-        newXSproto("Nodave::daveExecReadRequest", XS_Nodave_daveExecReadRequest, file, "$$$");
-        newXSproto("Nodave::daveUseResult", XS_Nodave_daveUseResult, file, "$$$");
-        newXSproto("Nodave::daveFreeResults", XS_Nodave_daveFreeResults, file, "$");
-        newXSproto("Nodave::davePrepareWriteRequest", XS_Nodave_davePrepareWriteRequest, file, "$$");
-        newXSproto("Nodave::daveAddVarToWriteRequest", XS_Nodave_daveAddVarToWriteRequest, file, "$$$$$$");
-        newXSproto("Nodave::daveAddBitVarToWriteRequest", XS_Nodave_daveAddBitVarToWriteRequest, file, "$$$$$$");
-        newXSproto("Nodave::daveAddVarToReadRequest", XS_Nodave_daveAddVarToReadRequest, file, "$$$$$");
-        newXSproto("Nodave::daveAddBitVarToReadRequest", XS_Nodave_daveAddBitVarToReadRequest, file, "$$$$$");
-        newXSproto("Nodave::setPort", XS_Nodave_setPort, file, "$$$");
-        newXSproto("Nodave::openSocket", XS_Nodave_openSocket, file, "$$");
-        newXSproto("Nodave::closePort", XS_Nodave_closePort, file, "$");
-        newXSproto("Nodave::closeSocket", XS_Nodave_closeSocket, file, "$");
-        newXSproto("Nodave::daveGetTimeout", XS_Nodave_daveGetTimeout, file, "$");
-        newXSproto("Nodave::daveSetTimeout", XS_Nodave_daveSetTimeout, file, "$$");
-        newXSproto("Nodave::daveGetName", XS_Nodave_daveGetName, file, "$");
-        newXSproto("Nodave::daveGetAnswLen", XS_Nodave_daveGetAnswLen, file, "$");
-        newXSproto("Nodave::daveGetMaxPDULen", XS_Nodave_daveGetMaxPDULen, file, "$");
-        newXSproto("Nodave::daveGetMPIAdr", XS_Nodave_daveGetMPIAdr, file, "$");
-        newXSproto("Nodave::daveGetErrorOfResult", XS_Nodave_daveGetErrorOfResult, file, "$$");
-        newXSproto("Nodave::daveForceDisconnectIBH", XS_Nodave_daveForceDisconnectIBH, file, "$$$$");
-        newXSproto("Nodave::daveForce200", XS_Nodave_daveForce200, file, "$$$$");
-        newXSproto("Nodave::daveGetOrderCode", XS_Nodave_daveGetOrderCode, file, "$");
-        newXSproto("Nodave::daveReadSZL", XS_Nodave_daveReadSZL, file, "$$$");
-        newXSproto("Nodave::daveListReachablePartners", XS_Nodave_daveListReachablePartners, file, "$");
+        (void)newXSproto_portable("Nodave::daveStrerror", XS_Nodave_daveStrerror, file, "$");
+        (void)newXSproto_portable("Nodave::daveSetDebug", XS_Nodave_daveSetDebug, file, "$");
+        (void)newXSproto_portable("Nodave::daveGetDebug", XS_Nodave_daveGetDebug, file, "");
+        (void)newXSproto_portable("Nodave::daveNewInterface", XS_Nodave_daveNewInterface, file, "$$$$$$");
+        (void)newXSproto_portable("Nodave::daveNewConnection", XS_Nodave_daveNewConnection, file, "$$$$");
+        (void)newXSproto_portable("Nodave::daveGetResponse", XS_Nodave_daveGetResponse, file, "$");
+        (void)newXSproto_portable("Nodave::daveSendMessage", XS_Nodave_daveSendMessage, file, "$");
+        (void)newXSproto_portable("Nodave::daveDumpPDU", XS_Nodave_daveDumpPDU, file, "$");
+        (void)newXSproto_portable("Nodave::daveDump", XS_Nodave_daveDump, file, "$$$");
+        (void)newXSproto_portable("Nodave::daveBlockName", XS_Nodave_daveBlockName, file, "$");
+        (void)newXSproto_portable("Nodave::daveAreaName", XS_Nodave_daveAreaName, file, "$");
+        (void)newXSproto_portable("Nodave::daveSwapIed_16", XS_Nodave_daveSwapIed_16, file, "$");
+        (void)newXSproto_portable("Nodave::daveSwapIed_32", XS_Nodave_daveSwapIed_32, file, "$");
+        (void)newXSproto_portable("Nodave::daveGetFloatAt", XS_Nodave_daveGetFloatAt, file, "$$");
+        (void)newXSproto_portable("Nodave::toPLCfloat", XS_Nodave_toPLCfloat, file, "$");
+        (void)newXSproto_portable("Nodave::daveToPLCfloat", XS_Nodave_daveToPLCfloat, file, "$");
+        (void)newXSproto_portable("Nodave::daveGetS8from", XS_Nodave_daveGetS8from, file, "$$");
+        (void)newXSproto_portable("Nodave::daveGetU8from", XS_Nodave_daveGetU8from, file, "$$");
+        (void)newXSproto_portable("Nodave::daveGetS16from", XS_Nodave_daveGetS16from, file, "$$");
+        (void)newXSproto_portable("Nodave::daveGetU16from", XS_Nodave_daveGetU16from, file, "$$");
+        (void)newXSproto_portable("Nodave::daveGetS32from", XS_Nodave_daveGetS32from, file, "$$");
+        (void)newXSproto_portable("Nodave::daveGetU32from", XS_Nodave_daveGetU32from, file, "$$");
+        (void)newXSproto_portable("Nodave::daveGetFloatfrom", XS_Nodave_daveGetFloatfrom, file, "$$");
+        (void)newXSproto_portable("Nodave::daveGetS8", XS_Nodave_daveGetS8, file, "$");
+        (void)newXSproto_portable("Nodave::daveGetU8", XS_Nodave_daveGetU8, file, "$");
+        (void)newXSproto_portable("Nodave::daveGetS16", XS_Nodave_daveGetS16, file, "$");
+        (void)newXSproto_portable("Nodave::daveGetU16", XS_Nodave_daveGetU16, file, "$");
+        (void)newXSproto_portable("Nodave::daveGetS32", XS_Nodave_daveGetS32, file, "$");
+        (void)newXSproto_portable("Nodave::daveGetU32", XS_Nodave_daveGetU32, file, "$");
+        (void)newXSproto_portable("Nodave::daveGetFloat", XS_Nodave_daveGetFloat, file, "$");
+        (void)newXSproto_portable("Nodave::daveGetS8At", XS_Nodave_daveGetS8At, file, "$$");
+        (void)newXSproto_portable("Nodave::daveGetU8At", XS_Nodave_daveGetU8At, file, "$$");
+        (void)newXSproto_portable("Nodave::daveGetS16At", XS_Nodave_daveGetS16At, file, "$$");
+        (void)newXSproto_portable("Nodave::daveGetU16At", XS_Nodave_daveGetU16At, file, "$$");
+        (void)newXSproto_portable("Nodave::daveGetS32At", XS_Nodave_daveGetS32At, file, "$$");
+        (void)newXSproto_portable("Nodave::daveGetU32At", XS_Nodave_daveGetU32At, file, "$$");
+        (void)newXSproto_portable("Nodave::daveGetSeconds", XS_Nodave_daveGetSeconds, file, "$$");
+        (void)newXSproto_portable("Nodave::daveGetSecondsAt", XS_Nodave_daveGetSecondsAt, file, "$$");
+        (void)newXSproto_portable("Nodave::daveGetCounterValue", XS_Nodave_daveGetCounterValue, file, "$$");
+        (void)newXSproto_portable("Nodave::daveGetCounterValueAt", XS_Nodave_daveGetCounterValueAt, file, "$$");
+        (void)newXSproto_portable("Nodave::daveConnectPLC", XS_Nodave_daveConnectPLC, file, "$");
+        (void)newXSproto_portable("Nodave::daveReadBytes", XS_Nodave_daveReadBytes, file, "$$$$$");
+        (void)newXSproto_portable("Nodave::daveWriteBytes", XS_Nodave_daveWriteBytes, file, "$$$$$$");
+        (void)newXSproto_portable("Nodave::daveReadBits", XS_Nodave_daveReadBits, file, "$$$$;$");
+        (void)newXSproto_portable("Nodave::daveWriteBits", XS_Nodave_daveWriteBits, file, "$$$$$$");
+        (void)newXSproto_portable("Nodave::daveSetBit", XS_Nodave_daveSetBit, file, "$$$$$");
+        (void)newXSproto_portable("Nodave::daveClrBit", XS_Nodave_daveClrBit, file, "$$$$$");
+        (void)newXSproto_portable("Nodave::daveNewPDU", XS_Nodave_daveNewPDU, file, "");
+        (void)newXSproto_portable("Nodave::daveNewResultSet", XS_Nodave_daveNewResultSet, file, "");
+        (void)newXSproto_portable("Nodave::daveInitAdapter", XS_Nodave_daveInitAdapter, file, "$");
+        (void)newXSproto_portable("Nodave::daveDisconnectPLC", XS_Nodave_daveDisconnectPLC, file, "$");
+        (void)newXSproto_portable("Nodave::daveDisconnectAdapter", XS_Nodave_daveDisconnectAdapter, file, "$");
+        (void)newXSproto_portable("Nodave::daveStop", XS_Nodave_daveStop, file, "$");
+        (void)newXSproto_portable("Nodave::daveStart", XS_Nodave_daveStart, file, "$");
+        (void)newXSproto_portable("Nodave::davePrepareReadRequest", XS_Nodave_davePrepareReadRequest, file, "$$");
+        (void)newXSproto_portable("Nodave::daveExecReadRequest", XS_Nodave_daveExecReadRequest, file, "$$$");
+        (void)newXSproto_portable("Nodave::daveUseResult", XS_Nodave_daveUseResult, file, "$$$");
+        (void)newXSproto_portable("Nodave::daveFreeResults", XS_Nodave_daveFreeResults, file, "$");
+        (void)newXSproto_portable("Nodave::davePrepareWriteRequest", XS_Nodave_davePrepareWriteRequest, file, "$$");
+        (void)newXSproto_portable("Nodave::daveAddVarToWriteRequest", XS_Nodave_daveAddVarToWriteRequest, file, "$$$$$$");
+        (void)newXSproto_portable("Nodave::daveAddBitVarToWriteRequest", XS_Nodave_daveAddBitVarToWriteRequest, file, "$$$$$$");
+        (void)newXSproto_portable("Nodave::daveAddVarToReadRequest", XS_Nodave_daveAddVarToReadRequest, file, "$$$$$");
+        (void)newXSproto_portable("Nodave::daveAddBitVarToReadRequest", XS_Nodave_daveAddBitVarToReadRequest, file, "$$$$$");
+        (void)newXSproto_portable("Nodave::setPort", XS_Nodave_setPort, file, "$$$");
+        (void)newXSproto_portable("Nodave::openSocket", XS_Nodave_openSocket, file, "$$");
+        (void)newXSproto_portable("Nodave::closePort", XS_Nodave_closePort, file, "$");
+        (void)newXSproto_portable("Nodave::closeSocket", XS_Nodave_closeSocket, file, "$");
+        (void)newXSproto_portable("Nodave::daveGetTimeout", XS_Nodave_daveGetTimeout, file, "$");
+        (void)newXSproto_portable("Nodave::daveSetTimeout", XS_Nodave_daveSetTimeout, file, "$$");
+        (void)newXSproto_portable("Nodave::daveGetName", XS_Nodave_daveGetName, file, "$");
+        (void)newXSproto_portable("Nodave::daveGetAnswLen", XS_Nodave_daveGetAnswLen, file, "$");
+        (void)newXSproto_portable("Nodave::daveGetMaxPDULen", XS_Nodave_daveGetMaxPDULen, file, "$");
+        (void)newXSproto_portable("Nodave::daveGetMPIAdr", XS_Nodave_daveGetMPIAdr, file, "$");
+        (void)newXSproto_portable("Nodave::daveGetErrorOfResult", XS_Nodave_daveGetErrorOfResult, file, "$$");
+        (void)newXSproto_portable("Nodave::daveForceDisconnectIBH", XS_Nodave_daveForceDisconnectIBH, file, "$$$$");
+        (void)newXSproto_portable("Nodave::daveForce200", XS_Nodave_daveForce200, file, "$$$$");
+        (void)newXSproto_portable("Nodave::daveGetOrderCode", XS_Nodave_daveGetOrderCode, file, "$");
+        (void)newXSproto_portable("Nodave::daveReadSZL", XS_Nodave_daveReadSZL, file, "$$$");
+        (void)newXSproto_portable("Nodave::daveListReachablePartners", XS_Nodave_daveListReachablePartners, file, "$");
         newXS("DaveInterface::DESTROY", XS_DaveInterface_DESTROY, file);
         newXS("DaveConnection::DESTROY", XS_DaveConnection_DESTROY, file);
         newXS("DavePDU::DESTROY", XS_DavePDU_DESTROY, file);
         newXS("DaveResultSet::DESTROY", XS_DaveResultSet_DESTROY, file);
-    if (PL_unitcheckav)
-         call_list(PL_scopestack_ix, PL_unitcheckav);
+#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
+  if (PL_unitcheckav)
+       call_list(PL_scopestack_ix, PL_unitcheckav);
+#endif
     XSRETURN_YES;
 }
 
Binärdateien ../libnodave-0.8.4.6/PERL/Nodave.o and ../libnodave-0.8.5/PERL/Nodave.o sind verschieden.
Nur in ../libnodave-0.8.5: setport.o.
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/setportw.c ../libnodave-0.8.5/setportw.c
--- ../libnodave-0.8.4.6/setportw.c	2007-01-08 23:24:30.000000000 +0100
+++ ../libnodave-0.8.5/setportw.c	2013-05-19 10:40:51.000000000 +0200
@@ -73,9 +73,22 @@
 	dcb.fOutxCtsFlow=FALSE;
 	dcb.fOutxDsrFlow=FALSE;
 //	dcb.fRtsControl=FALSE;   // this seems to be the evil. Guess do not understand the meaning of this parameter
-	dcb.fRtsControl=TRUE;
+//	dcb.fRtsControl=TRUE;
+//  from winbase.h :                    //****** ADD
+//#define RTS_CONTROL_DISABLE 0         //****** ADD
+//#define RTS_CONTROL_ENABLE 1          //****** ADD
+//#define RTS_CONTROL_HANDSHAKE 2       //****** ADD
+	dcb.fRtsControl=RTS_CONTROL_ENABLE; //****** ADD
+//#define RTS_CONTROL_TOGGLE 3          //****** ADD
+
 	dcb.fTXContinueOnXoff=TRUE;
-	dcb.StopBits=2;  ///that was 2 !!!
+//	dcb.StopBits=2;  ///that was 2 !!!   //****** REMOVE
+//  from winbase.h :                     //****** ADD
+//#define ONESTOPBIT	0                //****** ADD
+//#define ONE5STOPBITS	1                //****** ADD
+//#define TWOSTOPBITS	2                //****** ADD
+	dcb.StopBits=TWOSTOPBITS;        //****** ADD
+ 
 	if (0==strncmp(baud,"115200",6))
 	dcb.BaudRate = CBR_115200;
     else if (0==strncmp(baud,"57600",5))
@@ -108,7 +121,7 @@
 	dcb.Parity = 0;
 	else if (daveDebug & daveDebugPrintErrors) {
 	    printf(ThisModule "illegal parity mode:%c\n", parity);
-	}	    
+	}
 
 	SetCommState(hComm,&dcb);
 //	printf("got Comm State. %d\n ",dcb.BaudRate);
@@ -131,4 +144,6 @@
     12/17/2004 1st Version for Windows.
     04/03/2005 Hopefully really fixed COM port setting.
     05/08/2005 Removed printfs for quiet operation.
+-Version 0.8.5
+    05/19/2013 Applied changes from Keith
 */
Nur in ../libnodave-0.8.5: setportw.obj.
Binärdateien ../libnodave-0.8.4.6/testAS511 and ../libnodave-0.8.5/testAS511 sind verschieden.
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/testAS511.c ../libnodave-0.8.5/testAS511.c
--- ../libnodave-0.8.4.6/testAS511.c	2007-10-26 13:24:44.000000000 +0200
+++ ../libnodave-0.8.5/testAS511.c	2013-05-17 22:04:57.000000000 +0200
@@ -166,7 +166,7 @@
 	doClear, doNewfunctions, doWbit,
 	initSuccess, doRun, doStop, doReadout, doList, doListall, doSFBandSFC,
 	doSync, doReadTime, doGetHeaders, doTestMany, doDump, aLongDB,
-	res, speed, localMPI, plcMPI, plc2MPI, wbit, doReadDB, dbReadLen;
+	res, speed, localMPI, wbit, doReadDB, dbReadLen;
     PDU p;	
     float d;
     uc * buffer;
@@ -196,9 +196,6 @@
     dbReadLen=10;
     
     speed=daveSpeed187k;
-    localMPI=0;
-    plcMPI=2;
-    plc2MPI=-1;
     
     if (argc<2) {
 	usage();
@@ -291,7 +288,7 @@
 	    printf("Couldn't connect to Adapter!.\n Please try again. You may also try the option -2 for some adapters.\n");	
 	    return -3;
 	}
-	dc =daveNewConnection(di,plcMPI,0,0);
+	dc =daveNewConnection(di,2,0,0);
 	printf("ConnectPLC\n");
 	if (0==daveConnectPLC(dc)) {;
 	    if(doWbit) {
@@ -593,4 +590,5 @@
     04/09/05  removed CYGWIN defines. As there were no more differences against LINUX, it should 
 	      work with LINUX defines.
     09/11/05  added a test for daveReadManyBytes
+    05/17/13  removed meaningless MPI address variables
 */
Nur in ../libnodave-0.8.5: testAS511.exe.
Nur in ../libnodave-0.8.5: testAS511.exp.
Nur in ../libnodave-0.8.5: testAS511.lib.
Nur in ../libnodave-0.8.5: testAS511.o.
Nur in ../libnodave-0.8.5: testAS511.obj.
Binärdateien ../libnodave-0.8.4.6/testIBH and ../libnodave-0.8.5/testIBH sind verschieden.
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/testIBH.c ../libnodave-0.8.5/testIBH.c
--- ../libnodave-0.8.4.6/testIBH.c	2009-07-10 22:55:14.000000000 +0200
+++ ../libnodave-0.8.5/testIBH.c	2013-05-21 15:29:32.000000000 +0200
@@ -7,7 +7,7 @@
  * This is alpha software. Use entirely on your own risk.             * 
  **********************************************************************
  
- (C) Thomas Hergenhahn (thomas.hergenhahn@web.de) 2002, 2003.
+ (C) Thomas Hergenhahn (thomas.hergenhahn@web.de) 2002...2013.
 
  This is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
@@ -27,7 +27,8 @@
 #include <stdio.h>
 #include <string.h>
 
-#include "nodavesimple.h"
+//#include "nodavesimple.h"
+#include "nodave.h"
 /*
     Do NOT include nodavesimple.h to your own programs. It is just here to demonstrate
     that nodavesimple.h is enough to compile all the basic test programs.
@@ -72,7 +73,10 @@
     printf("--list show program and data blocks in PLC.\n");
     printf("--readout read program and data blocks from PLC.\n");
     printf("--readoutall read all program and data blocks from PLC. Includes SFBs and SFCs.\n");
-    printf("--debug=<number> will set daveDebug to number.\n");
+    printf("--route=subnetId,subnetId,PLC address. Try routing. ");
+    printf("	subnetID are the two values you see in Step7 or NetPro. PLC address is a number (MPI,Profibus) or an IP adress.\n");
+    printf("	Examples: --route=0x0125,0x0013,1 connects to PLC 1 in an MPI/Profibus subnet.\n");
+    printf("	Examples: --route=0x0125,0x0013,192.168.1.51 connects to PLC with IP 192.168.1.51 in an Ethernet subnet.\n");    printf("--debug=<number> will set daveDebug to number.\n");
     printf("--area=<number> try to use number as a memory area code.\n");
     printf("--reset tries to reset the NetLink.\n");
     printf("Example: testIBH -w 192.168.1.1\n");
@@ -223,12 +227,20 @@
     int i,j, a,b,c, adrPos, doWrite, doBenchmark, 
 	doSZLread, doMultiple, doClear, doNewfunctions, doWbit,
 	initSuccess, doSZLreadAll, doRun, doStop, doReadout, doSFBandSFC, doList, doListAll,
-	doReadTime, doSync, doReset,
+	doReadTime, doSync, doReset, doRouting,
 	saveDebug, testArea,
 	res, useProto, speed, localMPI, plcMPI, plc2MPI, wbit;
     PDU p;	
     float d;
     char buf1 [davePartnerListSize];
+
+    char routeargs[100];
+    char * first,*second;
+    int subnet1;
+    int subnet3;
+    int PLCadrsize;
+    uc PLCaddress[4];
+
     daveInterface * di;
     daveConnection * dc, * dc2;
     _daveOSserialType fds;
@@ -253,6 +265,7 @@
     doSync=0;
     doList=0;
     doReset=0;
+    doRouting=0;
     
     useProto=daveProtoMPI_IBH;
     speed=daveSpeed187k;
@@ -306,6 +319,32 @@
 	} else
 	if (strncmp(argv[adrPos],"--reset",7)==0) {
 	    doReset=1;
+	} else if (strncmp(argv[adrPos],"--route=",8)==0) {
+	    doRouting=1;
+	    strncpy(routeargs,argv[adrPos]+8, 100);
+	    printf("routing arguments: %s\n",routeargs);
+	    subnet1=strtol(routeargs,&first,16);
+	    printf("1st part subnet ID: %d\n",subnet1);
+	    first++;
+	    subnet3=strtol(first,&first,16);
+	    printf("2nd part subnet ID: %d\n",subnet3);
+	    first++;
+	    printf("rest: %s\n",first);
+	    PLCaddress[0]=strtol(first,&first,10);
+	    if (strlen(first)!=0) {
+		printf("PLC address is IP\n");
+		PLCadrsize=4;
+		first++;
+		PLCaddress[1]=strtol(first,&first,10);
+		first++;
+		PLCaddress[2]=strtol(first,&first,10);
+		first++;
+		PLCaddress[3]=strtol(first,&first,10);
+		
+	    } else {
+		printf("PLC address: %d\n", PLCaddress[0]);
+		PLCadrsize=1;
+	    }
 	} else
 	if (strncmp(argv[adrPos],"--debug=",8)==0) {
 	    daveSetDebug(atol(argv[adrPos]+8));
@@ -383,10 +422,15 @@
 	    } else daveDisconnectAdapter(di);
 	}
 	if (!initSuccess) {
-	    printf("Couldn't connect to Adapter!.\n Please try again. You may also try the option -2 for some adapters.\n");	
+	    printf("Couldn't connect to Adapter!.\n Please try again. You may also try the option -2 for some adapters.\n");
 	    return -3;
 	}
-	dc =daveNewConnection(di,plcMPI,0,0);
+	dc =daveNewConnection(di,plcMPI,0,2);
+	if (doRouting) {
+	    daveSetRoutingDestination(dc, subnet1, subnet3, PLCadrsize, PLCaddress);
+	}
+
+	
 	if(plc2MPI>=0)
 	    dc2 =daveNewConnection(di,plc2MPI,0,0);
 	else
Nur in ../libnodave-0.8.5: testIBH.exe.
Nur in ../libnodave-0.8.5: testIBH.exp.
Nur in ../libnodave-0.8.5: testIBH.lib.
Nur in ../libnodave-0.8.5: testIBH.o.
Nur in ../libnodave-0.8.5: testIBH.obj.
Binärdateien ../libnodave-0.8.4.6/testISO_TCP and ../libnodave-0.8.5/testISO_TCP sind verschieden.
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/testISO_TCP.c ../libnodave-0.8.5/testISO_TCP.c
--- ../libnodave-0.8.4.6/testISO_TCP.c	2009-07-11 00:44:38.000000000 +0200
+++ ../libnodave-0.8.5/testISO_TCP.c	2013-05-21 19:56:12.000000000 +0200
@@ -29,7 +29,8 @@
 #include <stdio.h>
 #include <string.h>
 
-#include "nodavesimple.h"
+//#include "nodavesimple.h"
+#include "nodave.h"
 #include "openSocket.h"
 
 #ifdef LINUX
@@ -155,6 +156,10 @@
     printf("-s stops the PLC.\n");
     printf("-r tries to put the PLC in run mode.\n");
     printf("--readout read program and data blocks from PLC.\n");
+    printf("--route=subnetId,subnetId,PLC address. Try routing. ");
+    printf("	subnetID are the two values you see in Step7 or NetPro. PLC address is a number (MPI,Profibus) or an IP adress.\n");
+    printf("	Examples: --route=0x0125,0x0013,1 connects to PLC 1 in an MPI/Profibus subnet.\n");
+    printf("	Examples: --route=0x0125,0x0013,192.168.1.51 connects to PLC with IP 192.168.1.51 in an Ethernet subnet.\n");
     printf("--readoutall read all program and data blocks from PLC. Includes SFBs and SFCs.\n");
     printf("--slot=<number> sets slot for PLC (default is 2).\n");
     printf("--ram2rom tries to Copy RAM to ROM.\n");    
@@ -162,7 +167,8 @@
     printf("Example: testISO_TCP -w 192.168.19.1\n");
 }
 
-void loadBlocksOfType(daveConnection * dc, int blockType) {
+
+void loadBlocksOfType(daveConnection * dc, int blockType, int doReadout) {
     int j, i, uploadID, len, more;
 #ifdef UNIX_STYLE
     int fd;
@@ -172,7 +178,7 @@
     unsigned long res;
 #endif	        
     char blockName [20];
-    uc blockBuffer[20000],*bb;
+    uc blockBuffer[70000],*bb;
     daveBlockEntry dbe[256];   
     j=daveListBlocksOfType(dc, blockType, dbe);
     if (j<0) {
@@ -180,11 +186,13 @@
 	return;
     }
     printf("%d blocks of type %s\n",j,daveBlockName(blockType));
+    
     for (i=0; i<j; i++) {
 	printf("%s%d  %d %d\n",
 	    daveBlockName(blockType),
 	    dbe[i].number, dbe[i].type[0],dbe[i].type[1]);	
 	bb=blockBuffer;
+	if(doReadout) {	
 	len=0;
 	if (0==initUpload(dc, blockType, dbe[i].number, &uploadID)) {
     	    do {
@@ -203,18 +211,37 @@
     	    WriteFile(fd, blockBuffer, len, &res, NULL);
     	    CloseHandle(fd);
 #endif	    
-
     	    endUpload(dc,uploadID);
-	}    
+	} 
+    }	
     }
 }
 
+void getBlockHeadersOfType(daveConnection * dc, int blockType) {
+    int j, i;
+    daveBlockEntry dbe[256]; 
+    j=daveListBlocksOfType(dc, blockType, dbe);
+    if (j<0) {
+	printf("error %d = %s\n",-j,daveStrerror(-j));
+	return;
+    }
+    printf("%d blocks of type %s\n",j,daveBlockName(blockType));
+    
+    for (i=0; i<j; i++) {
+	printf("%s%d  %d %d\n",
+	    daveBlockName(blockType),
+	    dbe[i].number, dbe[i].type[0],dbe[i].type[1]);	
+	daveGetBlockInfo(dc, NULL, blockType,dbe[i].number);
+	_daveDump("header",dc->_resultPointer,78);
+    }	
+}
+
 #include "benchmark.c"
 
 int main(int argc, char **argv) {
     int a,b,c,adrPos,doWrite,doBenchmark, doSZLread, doMultiple, doClear,
 	res, useProtocol,doSZLreadAll, doRun, doStop, doCopyRAMtoROM, doReadout, doSFBandSFC,
-	doNewfunctions, saveDebug,
+	doNewfunctions, saveDebug, doRouting, doList, doListall,
 	useSlot;
 #ifdef PLAY_WITH_KEEPALIVE    	
     int opt;
@@ -226,6 +253,14 @@
     PDU p;
     daveResultSet rs;
     
+    char routeargs[100];
+    char * first,*second;
+    int subnet1;
+    int subnet3;
+    int PLCadrsize;
+    uc PLCaddress[4];
+
+    
     daveSetDebug(daveDebugPrintErrors);
     adrPos=1;
     doWrite=0;
@@ -240,11 +275,15 @@
     doReadout=0;
     doSFBandSFC=0;
     doNewfunctions=0;
-    
+    doRouting=0;
+    doList=0;
+    doListall=0;
     useProtocol=daveProtoISOTCP;
     useSlot=2;
     
-    
+
+
+
     if (argc<2) {
 	usage();
 	exit(-1);
@@ -260,6 +299,11 @@
 	    doStop=1;
 	} else if (strcmp(argv[adrPos],"-r")==0) {
 	    doRun=1;
+	} else if (strncmp(argv[adrPos],"--listall",9)==0) {
+	    doListall=1;
+	    doList=1;
+	} else if (strncmp(argv[adrPos],"--list",6)==0) {
+	    doList=1;
 	} else if (strncmp(argv[adrPos],"--ram2rom",9)==0) {
 	    doCopyRAMtoROM=1;    
 	} else if (strncmp(argv[adrPos],"--readoutall",12)==0) {
@@ -267,6 +311,32 @@
 	    doSFBandSFC=1;
 	} else if (strncmp(argv[adrPos],"--readout",9)==0) {
 	    doReadout=1;
+	} else if (strncmp(argv[adrPos],"--route=",8)==0) {
+	    doRouting=1;
+	    strncpy(routeargs,argv[adrPos]+8, 100);
+	    printf("routing arguments: %s\n",routeargs);
+	    subnet1=strtol(routeargs,&first,16);
+	    printf("1st part subnet ID: %d\n",subnet1);
+	    first++;
+	    subnet3=strtol(first,&first,16);
+	    printf("2nd part subnet ID: %d\n",subnet3);
+	    first++;
+	    printf("rest: %s\n",first);
+	    PLCaddress[0]=strtol(first,&first,10);
+	    if (strlen(first)!=0) {
+		printf("PLC address is IP\n");
+		PLCadrsize=4;
+		first++;
+		PLCaddress[1]=strtol(first,&first,10);
+		first++;
+		PLCaddress[2]=strtol(first,&first,10);
+		first++;
+		PLCaddress[3]=strtol(first,&first,10);
+		
+	    } else {
+		printf("PLC address: %d\n", PLCaddress[0]);
+		PLCadrsize=1;
+	    }
 	} else if (strncmp(argv[adrPos],"--slot=",7)==0) {
 	    useSlot=atol(argv[adrPos]+7);
 	} else if (strcmp(argv[adrPos],"-d")==0) {
@@ -309,6 +379,10 @@
 	di =daveNewInterface(fds,"IF1",0, useProtocol, daveSpeed187k);
 	daveSetTimeout(di,5000000);
 	dc =daveNewConnection(di,2,0,useSlot);  // insert your rack and slot here
+
+	if (doRouting) {
+	    daveSetRoutingDestination(dc, subnet1, subnet3, PLCadrsize, PLCaddress);
+	}
 	
 	if (0==daveConnectPLC(dc)) {
 	    printf("Connected.\n");
@@ -387,7 +461,19 @@
 	}    
 	if(doSZLreadAll) {
 	    readSZLAll(dc);
-	}    
+	}
+	if(doList||doReadout) { // if readout is not set, loadBlocksOfType will only ist block names
+	    daveListBlocks(dc,NULL);
+	    loadBlocksOfType(dc, daveBlockType_OB, doReadout);
+	    loadBlocksOfType(dc, daveBlockType_FB, doReadout);
+	    loadBlocksOfType(dc, daveBlockType_FC, doReadout);
+	    loadBlocksOfType(dc, daveBlockType_DB, doReadout);
+	    loadBlocksOfType(dc, daveBlockType_SDB, doReadout);
+	    if ((doSFBandSFC) ||(doListall)){	    
+		loadBlocksOfType(dc, daveBlockType_SFB, doReadout);
+	        loadBlocksOfType(dc, daveBlockType_SFC, doReadout);
+	    }
+	}
 	if(doMultiple) {
     	    printf("Now testing read multiple variables.\n"
 		"This will read 1 Byte from inputs,\n"
@@ -619,18 +705,7 @@
 	    res = daveCopyRAMtoROM(dc);
             printf("RetVal=(%04X)\n",res);  	    
 	}
-	if(doReadout) {
-	    loadBlocksOfType(dc, daveBlockType_OB);
-	    loadBlocksOfType(dc, daveBlockType_FB);
-	    loadBlocksOfType(dc, daveBlockType_FC);
-	    loadBlocksOfType(dc, daveBlockType_DB);
-	    loadBlocksOfType(dc, daveBlockType_SDB);
-	    if (doSFBandSFC){	    
-		loadBlocksOfType(dc, daveBlockType_SFB);
-	        loadBlocksOfType(dc, daveBlockType_SFC);
-	    }
-	}    
-	
+
 	if(doBenchmark) {
 	    if(useProtocol==daveProtoISOTCP243) { // we have a 200 CPU, use V memory
 		rBenchmark(dc, daveDB);
Nur in ../libnodave-0.8.5: testISO_TCP.exe.
Nur in ../libnodave-0.8.5: testISO_TCP.exp.
Nur in ../libnodave-0.8.5: testISO_TCP.lib.
Binärdateien ../libnodave-0.8.4.6/testISO_TCPload and ../libnodave-0.8.5/testISO_TCPload sind verschieden.
Nur in ../libnodave-0.8.5: testISO_TCPload.exe.
Nur in ../libnodave-0.8.5: testISO_TCPload.exp.
Nur in ../libnodave-0.8.5: testISO_TCPload.lib.
Nur in ../libnodave-0.8.5: testISO_TCPload.o.
Nur in ../libnodave-0.8.5: testISO_TCPload.obj.
Nur in ../libnodave-0.8.5: testISO_TCP.o.
Nur in ../libnodave-0.8.5: testISO_TCP.obj.
Binärdateien ../libnodave-0.8.4.6/testMPI and ../libnodave-0.8.5/testMPI sind verschieden.
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/testMPI.c ../libnodave-0.8.5/testMPI.c
--- ../libnodave-0.8.4.6/testMPI.c	2007-10-26 13:22:42.000000000 +0200
+++ ../libnodave-0.8.5/testMPI.c	2013-05-22 17:48:01.000000000 +0200
@@ -66,6 +66,10 @@
     printf("--listall show program and data blocks in PLC. Includes SFBs and SFCs\n");
     printf("--readout read program and data blocks from PLC.\n");
     printf("--readoutall reads all program and data blocks from PLC. Includes SFBs and SFCs.\n");
+    printf("--route=subnetId,subnetId,PLC address. Try routing. ");
+    printf("	subnetID are the two values you see in Step7 or NetPro. PLC address is a number (MPI,Profibus) or an IP adress.\n");
+    printf("	Examples: --route=0x0125,0x0013,1 connects to PLC 1 in an MPI/Profibus subnet.\n");
+    printf("	Examples: --route=0x0125,0x0013,192.168.1.51 connects to PLC with IP 192.168.1.51 in an Ethernet subnet.\n");
     printf("--sync sets the PLC's clock to PC time.\n");
     printf("--many=<DB number> reads 2000 bytes from the given DB using daveReadManyBytes().\n");
     printf("  The DB should exist and be long enough.\n");
@@ -92,11 +96,11 @@
     uc c;
 #ifdef UNIX_STYLE
     printf("Press return to continue.\n");
-    read(0,&c,1);
+//    read(0,&c,1);
 #endif    
 #ifdef WIN_STYLE
     printf("Press return to continue.\n");
-    getch();
+//    getch();
 #endif    
 //#ifdef WIN_STYLE
 //    printf("Press return to continue.\n");
@@ -192,7 +196,7 @@
     unsigned long res;
 #endif	        
     char blockName [20];
-    uc blockBuffer[20000],*bb;
+    uc blockBuffer[70000],*bb;
     daveBlockEntry dbe[256];   
     j=daveListBlocksOfType(dc, blockType, dbe);
     if (j<0) {
@@ -256,7 +260,7 @@
     int i,j, a,b,c, adrPos, doWrite, doBenchmark, 
 	doSZLread, doMultiple, doClear, doNewfunctions, doWbit,
 	initSuccess, doSZLreadAll, doRun, doStop, doReadout, doList, doListall, doSFBandSFC,
-	doExperimental, doSync, doReadTime, doGetHeaders, doTestMany, doUsePhone, 
+	doExperimental, doSync, doReadTime, doGetHeaders, doTestMany, doUsePhone, doRouting,
 	aLongDB,
 	saveDebug,
 	res, useProto, speed, localMPI, plcMPI, plc2MPI, wbit, szlID, szlIndex;
@@ -270,7 +274,14 @@
     daveConnection * dc, *dc2;
     _daveOSserialType fds;
     daveResultSet rs;
-    
+
+    char routeargs[100];
+    char * first,*second;
+    int subnet1;
+    int subnet3;
+    int PLCadrsize;
+    uc PLCaddress[4];
+
     adrPos=1;
     doWrite=0;
     doBenchmark=0;
@@ -294,6 +305,7 @@
     doGetHeaders=0;
     doTestMany=0;
     doUsePhone=0;
+    doRouting=0;
     
     useProto=daveProtoMPI;
     speed=daveSpeed187k;
@@ -336,6 +348,33 @@
 	    doExperimental=1;
 	} else if (strncmp(argv[adrPos],"--readout",9)==0) {
 	    doReadout=1;
+	} else if (strncmp(argv[adrPos],"--route=",8)==0) {
+	    doRouting=1;
+	    strncpy(routeargs,argv[adrPos]+8, 100);
+	    printf("routing arguments: %s\n",routeargs);
+	    subnet1=strtol(routeargs,&first,16);
+	    printf("1st part subnet ID: %d\n",subnet1);
+	    first++;
+	    subnet3=strtol(first,&first,16);
+	    printf("2nd part subnet ID: %d\n",subnet3);
+	    first++;
+	    printf("rest: %s\n",first);
+	    PLCaddress[0]=strtol(first,&first,10);
+	    if (strlen(first)!=0) {
+		printf("PLC address is IP\n");
+		PLCadrsize=4;
+		first++;
+		PLCaddress[1]=strtol(first,&first,10);
+		first++;
+		PLCaddress[2]=strtol(first,&first,10);
+		first++;
+		PLCaddress[3]=strtol(first,&first,10);
+		
+	    } else {
+		printf("PLC address: %d\n", PLCaddress[0]);
+		PLCadrsize=1;
+	    }
+
 	} else if (strncmp(argv[adrPos],"--headers",9)==0) {
 	    doGetHeaders=1;
 	} else if (strncmp(argv[adrPos],"--many=",7)==0) {
@@ -484,6 +523,9 @@
 	    return -3;
 	}
 	dc =daveNewConnection(di,plcMPI,0,0);
+	if (doRouting) {
+	    daveSetRoutingDestination(dc, subnet1, subnet3, PLCadrsize, PLCaddress);
+	}
 	if(plc2MPI>=0)
 	    dc2 =daveNewConnection(di,plc2MPI,0,0);
 	else
@@ -538,6 +580,25 @@
 		printf("PLC FD4: %d\n", b);
 		printf("PLC FD8: %d\n", c);
 		printf("PLC FD12: %f\n", d);
+		
+		a=daveSwapIed_32(a+1);
+    		daveWriteBytes(dc,daveFlags,0,16+0,4,&a);
+    		b=daveSwapIed_32(b+2);
+    		daveWriteBytes(dc,daveFlags,0,16+4,4,&b);
+    		c=daveSwapIed_32(c+3);
+		daveWriteBytes(dc,daveFlags,0,16+8,4,&c);
+    		d=toPLCfloat(d+1.1);
+    		daveWriteBytes(dc,daveFlags,0,16+12,4,&d);
+    		
+    		a=daveSwapIed_32(a+1);
+    		daveWriteBytes(dc,daveFlags,0,32+0,4,&a);
+    		b=daveSwapIed_32(b+2);
+    		daveWriteBytes(dc,daveFlags,0,32+4,4,&b);
+    		c=daveSwapIed_32(c+3);
+		daveWriteBytes(dc,daveFlags,0,32+8,4,&c);
+    		d=toPLCfloat(d+1.1);
+    		daveWriteBytes(dc,daveFlags,0,32+12,4,&d);
+
 	    }
 	} else 
 	    printf("error %d=%s\n", res, daveStrerror(res));
@@ -846,7 +907,7 @@
 	        printf("FD0: %d\n",a);
 		printf("FD4: %d\n",b);
 		printf("FD8: %d\n",c);
-	        printf("FD12: %f\n",d);		
+	        printf("FD12: %f\n",d);
 	    } // doWrite
 	}	    
 
Nur in ../libnodave-0.8.5: testMPI.exe.
Nur in ../libnodave-0.8.5: testMPI.exp.
Binärdateien ../libnodave-0.8.4.6/testMPI_IBHload and ../libnodave-0.8.5/testMPI_IBHload sind verschieden.
Nur in ../libnodave-0.8.5: testMPI_IBHload.exe.
Nur in ../libnodave-0.8.5: testMPI_IBHload.exp.
Nur in ../libnodave-0.8.5: testMPI_IBHload.lib.
Nur in ../libnodave-0.8.5: testMPI_IBHload.o.
Nur in ../libnodave-0.8.5: testMPI_IBHload.obj.
Nur in ../libnodave-0.8.5: testMPI.lib.
Binärdateien ../libnodave-0.8.4.6/testMPIload and ../libnodave-0.8.5/testMPIload sind verschieden.
Nur in ../libnodave-0.8.5: testMPIload.exe.
Nur in ../libnodave-0.8.5: testMPIload.exp.
Nur in ../libnodave-0.8.5: testMPIload.lib.
Nur in ../libnodave-0.8.5: testMPIload.o.
Nur in ../libnodave-0.8.5: testMPIload.obj.
Nur in ../libnodave-0.8.5: testMPI.o.
Nur in ../libnodave-0.8.5: testMPI.obj.
Binärdateien ../libnodave-0.8.4.6/testNLpro and ../libnodave-0.8.5/testNLpro sind verschieden.
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/testNLpro.c ../libnodave-0.8.5/testNLpro.c
--- ../libnodave-0.8.4.6/testNLpro.c	2009-07-10 22:56:20.000000000 +0200
+++ ../libnodave-0.8.5/testNLpro.c	2013-05-21 15:29:48.000000000 +0200
@@ -6,8 +6,8 @@
  * DO NOT use it on PLC's when anything is connected to their outputs.*
  * This is alpha software. Use entirely on your own risk.             * 
  **********************************************************************
- 
- (C) Thomas Hergenhahn (thomas.hergenhahn@web.de) 2002, 2003.
+
+ (C) Thomas Hergenhahn (thomas.hergenhahn@web.de) 2002...2013.
 
  This is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
@@ -27,7 +27,8 @@
 #include <stdio.h>
 #include <string.h>
 
-#include "nodavesimple.h"
+//#include "nodavesimple.h"
+#include "nodave.h"
 /*
     Do NOT include nodavesimple.h to your own programs. It is just here to demonstrate
     that nodavesimple.h is enough to compile all the basic test programs.
@@ -73,6 +74,10 @@
     printf("--list show program and data blocks in PLC.\n");
     printf("--readout read program and data blocks from PLC.\n");
     printf("--readoutall read all program and data blocks from PLC. Includes SFBs and SFCs.\n");
+    printf("--route=subnetId,subnetId,PLC address. Try routing. ");
+    printf("	subnetID are the two values you see in Step7 or NetPro. PLC address is a number (MPI,Profibus) or an IP adress.\n");
+    printf("	Examples: --route=0x0125,0x0013,1 connects to PLC 1 in an MPI/Profibus subnet.\n");
+    printf("	Examples: --route=0x0125,0x0013,192.168.1.51 connects to PLC with IP 192.168.1.51 in an Ethernet subnet.\n");    printf("--debug=<number> will set daveDebug to number.\n");
     printf("--debug=<number> will set daveDebug to number.\n");
     printf("--area=<number> try to use number as a memory area code.\n");
     printf("Example: testIBH -w 192.168.1.1\n");
@@ -224,7 +229,7 @@
 	doSZLread, doMultiple, doClear, doNewfunctions, doWbit,
 	initSuccess, doSZLreadAll, doRun, doStop, doReadout, doSFBandSFC, doList, doListAll,
 	doLifeList, 
-	doReadTime, doSync, doReset,
+	doReadTime, doSync, doReset, doRouting,
 	saveDebug, testArea,
 	res, useProto, speed, localMPI, plcMPI, plc2MPI, wbit, szlID, szlIndex;
     PDU p;	
@@ -235,6 +240,13 @@
     _daveOSserialType fds;
     daveResultSet rs;
     
+    char routeargs[100];
+    char * first;
+    int subnet1;
+    int subnet3;
+    int PLCadrsize;
+    uc PLCaddress[4];
+
     adrPos=1;
     doWrite=0;
     doBenchmark=0;
@@ -256,6 +268,7 @@
     doReset=0;
     szlID=-1;
     szlIndex=-0;
+    doRouting=0;
     
     
     useProto=daveProtoNLpro;
@@ -310,8 +323,33 @@
 	} else
 	if (strncmp(argv[adrPos],"--reset",7)==0) {
 	    doReset=1;
-	} else
-	if (strncmp(argv[adrPos],"--debug=",8)==0) {
+	} else if (strncmp(argv[adrPos],"--route=",8)==0) {
+	    doRouting=1;
+	    strncpy(routeargs,argv[adrPos]+8, 100);
+	    printf("routing arguments: %s\n",routeargs);
+	    subnet1=strtol(routeargs,&first,16);
+	    printf("1st part subnet ID: %d\n",subnet1);
+	    first++;
+	    subnet3=strtol(first,&first,16);
+	    printf("2nd part subnet ID: %d\n",subnet3);
+	    first++;
+	    printf("rest: %s\n",first);
+	    PLCaddress[0]=strtol(first,&first,10);
+	    if (strlen(first)!=0) {
+		printf("PLC address is IP\n");
+		PLCadrsize=4;
+		first++;
+		PLCaddress[1]=strtol(first,&first,10);
+		first++;
+		PLCaddress[2]=strtol(first,&first,10);
+		first++;
+		PLCaddress[3]=strtol(first,&first,10);
+		
+	    } else {
+		printf("PLC address: %d\n", PLCaddress[0]);
+		PLCadrsize=1;
+	    }
+	} else if (strncmp(argv[adrPos],"--debug=",8)==0) {
 	    daveSetDebug(atol(argv[adrPos]+8));
 	    printf("setting debug to: 0x%lx\n",atol(argv[adrPos]+8));
 	} else
@@ -398,6 +436,11 @@
 	    return -3;
 	}
 	dc =daveNewConnection(di,plcMPI,0,0);
+	
+	if (doRouting) {
+	    daveSetRoutingDestination(dc, subnet1, subnet3, PLCadrsize, PLCaddress);
+	}
+	
 	if(plc2MPI>=0)
 	    dc2 =daveNewConnection(di,plc2MPI,0,0);
 	else
Nur in ../libnodave-0.8.5: testNLpro.exe.
Nur in ../libnodave-0.8.5: testNLpro.exp.
Nur in ../libnodave-0.8.5: testNLpro.lib.
Nur in ../libnodave-0.8.5: testNLpro.o.
Nur in ../libnodave-0.8.5: testNLpro.obj.
Binärdateien ../libnodave-0.8.4.6/testPPI and ../libnodave-0.8.5/testPPI sind verschieden.
Nur in ../libnodave-0.8.5: testPPI.exe.
Nur in ../libnodave-0.8.5: testPPI.exp.
Binärdateien ../libnodave-0.8.4.6/testPPI_IBH and ../libnodave-0.8.5/testPPI_IBH sind verschieden.
Nur in ../libnodave-0.8.5: testPPI_IBH.exe.
Nur in ../libnodave-0.8.5: testPPI_IBH.exp.
Nur in ../libnodave-0.8.5: testPPI_IBH.lib.
Binärdateien ../libnodave-0.8.4.6/testPPI_IBHload and ../libnodave-0.8.5/testPPI_IBHload sind verschieden.
Nur in ../libnodave-0.8.5: testPPI_IBHload.exe.
Nur in ../libnodave-0.8.5: testPPI_IBHload.exp.
Nur in ../libnodave-0.8.5: testPPI_IBHload.lib.
Nur in ../libnodave-0.8.5: testPPI_IBHload.o.
Nur in ../libnodave-0.8.5: testPPI_IBHload.obj.
Nur in ../libnodave-0.8.5: testPPI_IBH.o.
Nur in ../libnodave-0.8.5: testPPI_IBH.obj.
Nur in ../libnodave-0.8.5: testPPI.lib.
Binärdateien ../libnodave-0.8.4.6/testPPIload and ../libnodave-0.8.5/testPPIload sind verschieden.
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/testPPIload.c ../libnodave-0.8.5/testPPIload.c
--- ../libnodave-0.8.4.6/testPPIload.c	2007-10-26 13:18:28.000000000 +0200
+++ ../libnodave-0.8.5/testPPIload.c	2013-08-06 19:51:39.000000000 +0200
@@ -297,7 +297,7 @@
 			printf("Block sended\n");	
 			res=0;
 //			i = _daveReadChars(dc->iface, dc->msgIn+res, 2000000, daveMaxRawLen);
-			i = _daveReadChars2(dc->iface, dc->msgIn+res, daveMaxRawLen);
+			i = dc->iface->ifread(dc->iface, dc->msgIn+res, daveMaxRawLen);
 			if ((daveGetDebug() & daveDebugByte)!=0) {
 			    LOG3("i:%d res:%d\n",i,res);
 			}	
@@ -344,7 +344,7 @@
 		    printf("ACK for end sended\n");		
 		    res=0;
 //		    i = _daveReadChars(dc->iface, dc->msgIn+res, 2000000, daveMaxRawLen);
-		    i = _daveReadChars2(dc->iface, dc->msgIn+res, daveMaxRawLen);
+		    i = dc->iface->ifread(dc->iface, dc->msgIn+res, daveMaxRawLen);
 		    if ((daveGetDebug() & daveDebugByte)!=0) {
 		        LOG3("i:%d res:%d\n",i,res);
 		    }	
Nur in ../libnodave-0.8.5: testPPIload.exe.
Nur in ../libnodave-0.8.5: testPPIload.exp.
Nur in ../libnodave-0.8.5: testPPIload.lib.
Nur in ../libnodave-0.8.5: testPPIload.o.
Nur in ../libnodave-0.8.5: testPPIload.obj.
Nur in ../libnodave-0.8.5: testPPI.o.
Nur in ../libnodave-0.8.5: testPPI.obj.
Nur in ../libnodave-0.8.5: tests.
Nur in ../libnodave-0.8.5: tests1.
Nur in ../libnodave-0.8.5: tests2.
Nur in ../libnodave-0.8.5: tests3.
Nur in ../libnodave-0.8.5: tests4.
diff -u -r --strip-trailing-cr ../libnodave-0.8.4.6/testS7online.c ../libnodave-0.8.5/testS7online.c
--- ../libnodave-0.8.4.6/testS7online.c	2007-01-09 20:10:52.000000000 +0100
+++ ../libnodave-0.8.5/testS7online.c	2013-05-21 16:26:40.000000000 +0200
@@ -124,7 +124,7 @@
     printf("  with the 2nd one to demonstrate that this works.\n");
     printf("--local=<number> will set the local MPI adddres to number. Default is 0.\n");
     printf("--debug=<number> will set daveDebug to number.\n");
-    printf("Example: testS7online -w /S7online\n");
+    printf("Example: testS7online /S7online\n");
 }
 
 void wait() {
Nur in ../libnodave-0.8.5: testS7online.exe.
Nur in ../libnodave-0.8.5: testS7online.exp.
Nur in ../libnodave-0.8.5: testS7online.lib.
Nur in ../libnodave-0.8.5: testS7online.obj.
Nur in ../libnodave-0.8.4.6/win: libnodave.dll.
Nur in ../libnodave-0.8.4.6/win: libnodave.lib.
Nur in ../libnodave-0.8.4.6/win: testAS511.exe.
Nur in ../libnodave-0.8.4.6/win: testIBH.exe.
Nur in ../libnodave-0.8.4.6/win: testISO_TCP.exe.
Nur in ../libnodave-0.8.4.6/win: testISO_TCPload.exe.
Nur in ../libnodave-0.8.4.6/win: testMPI.exe.
Nur in ../libnodave-0.8.4.6/win: testMPI_IBHload.exe.
Nur in ../libnodave-0.8.4.6/win: testMPIload.exe.
Nur in ../libnodave-0.8.4.6/win: testNLpro.exe.
Nur in ../libnodave-0.8.4.6/win: testPPI.exe.
Nur in ../libnodave-0.8.4.6/win: testPPI_IBH.exe.
Nur in ../libnodave-0.8.4.6/win: testPPI_IBHload.exe.
Nur in ../libnodave-0.8.4.6/win: testPPIload.exe.
Nur in ../libnodave-0.8.4.6/win: testS7online.exe.
